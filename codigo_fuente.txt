Eres un ingeniero de software de élite especializado en el desarrollo de extensiones para navegadores, particularmente Chrome. Tienes una vasta experiencia en la implementación de tecnologías de Inteligencia Artificial en el navegador utilizando bibliotecas como transformers.js. Tu enfoque es la excelencia, la precisión y la optimización de rendimiento con baja latencia. 
Tu objetivo es mejorar y optimizar la base de código proporcionada, identificando y resolviendo problemas, creando nuevas funcionalidades y mejorando el rendimiento general del proyecto. 
A continuación, se presenta la base de código del proyecto. Cada archivo de código fuente está marcado con un indicador de inicio y fin, junto con el nombre y la ruta relativa del archivo:

/tsconfig.node.json:
------BEGIN OF FILE----
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "noEmit": true,
    "baseUrl": "."
  },
  "include": ["vite.config.ts"]
}

------END OF FILE----

/index.html:
------BEGIN OF FILE----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Distiller AI</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

------END OF FILE----

/tailwind.config.js:
------BEGIN OF FILE----
/** @type {import('tailwindcss').Config} */
module.exports = {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: "2rem",
			screens: {
				"2xl": "1400px",
			},
		},
		extend: {
			colors: {
				border: "hsl(var(--border))",
				input: "hsl(var(--input))",
				ring: "hsl(var(--ring))",
				background: "hsl(var(--background))",
				foreground: "hsl(var(--foreground))",
				primary: {
					DEFAULT: "hsl(var(--primary))",
					foreground: "hsl(var(--primary-foreground))",
				},
				secondary: {
					DEFAULT: "hsl(var(--secondary))",
					foreground: "hsl(var(--secondary-foreground))",
				},
				destructive: {
					DEFAULT: "hsl(var(--destructive))",
					foreground: "hsl(var(--destructive-foreground))",
				},
				muted: {
					DEFAULT: "hsl(var(--muted))",
					foreground: "hsl(var(--muted-foreground))",
				},
				accent: {
					DEFAULT: "hsl(var(--accent))",
					foreground: "hsl(var(--accent-foreground))",
				},
				popover: {
					DEFAULT: "hsl(var(--popover))",
					foreground: "hsl(var(--popover-foreground))",
				},
				card: {
					DEFAULT: "hsl(var(--card))",
					foreground: "hsl(var(--card-foreground))",
				},
			},
			borderRadius: {
				lg: "var(--radius)",
				md: "calc(var(--radius) - 2px)",
				sm: "calc(var(--radius) - 4px)",
			},
			keyframes: {
				"accordion-down": {
					from: { height: "0" },
					to: { height: "var(--radix-accordion-content-height)" },
				},
				"accordion-up": {
					from: { height: "var(--radix-accordion-content-height)" },
					to: { height: "0" },
				},
			},
			animation: {
				"accordion-down": "accordion-down 0.2s ease-out",
				"accordion-up": "accordion-up 0.2s ease-out",
			},
		},
	},
	plugins: [require("tailwindcss-animate")],
};

------END OF FILE----

/tsconfig.app.json:
------BEGIN OF FILE----
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}

------END OF FILE----

/offscreen.html:
------BEGIN OF FILE----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- <link rel="icon" type="image/svg+xml" href="/vite.svg" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Distiller AI</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/offscreen.tsx"></script>
  </body>
</html>

------END OF FILE----

/renovate.json:
------BEGIN OF FILE----
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": ["config:recommended"],
  "devDependencies": {
    "group": true
  },
  "packageRules": [
    {
      "updateTypes": ["minor", "patch", "pin"],
      "automerge": true
    },
    {
      "matchPackageNames": ["node"],
      "extends": ["schedule:monthly"]
    }
  ]
}

------END OF FILE----

/package.json:
------BEGIN OF FILE----
{
  "name": "chrome-extension-transcriptor",
  "private": true,
  "version": "0.0.19",
  "license": "MIT",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "check": "biome check . --config-path=./biome.json",
    "preview": "vite preview"
  },
  "dependencies": {
    "@huggingface/transformers": "3.6.3",
    "@mozilla/readability": "^0.5.0",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "class-variance-authority": "^0.7.0",
    "classnames": "^2.5.1",
    "clsx": "^2.1.1",
    "jotai": "^2.10.2",
    "lucide-react": "^0.525.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.0.0",
    "tailwindcss-animate": "^1.0.7",
    "turndown": "^7.2.0"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@types/audioworklet": "^0.0.77",
    "@types/chrome": "^0.1.0",
    "@types/dom-chromium-ai": "^0.0.6",
    "@types/node": "^22.0.0",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "@types/turndown": "^5.0.4",
    "@types/webspeechapi": "^0.0.29",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.19",
    "postcss": "^8.4.39",
    "tailwindcss": "^3.4.4",
    "typescript": "^5.5.3",
    "vite": "^6.0.0"
  }
}

------END OF FILE----

/components.json:
------BEGIN OF FILE----
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

------END OF FILE----

/tsconfig.json:
------BEGIN OF FILE----
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.node.json"
    }
  ],
  "compilerOptions": {
    "lib": ["dom", "ESNext"],
    "allowJs": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

------END OF FILE----

/sidepanel.html:
------BEGIN OF FILE----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Distiller AI</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/side-panel.tsx"></script>
  </body>
</html>

------END OF FILE----

/vite.config.ts:
------BEGIN OF FILE----
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path, { resolve } from "node:path";

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [react()],
	resolve: {
		alias: {
			"@": path.resolve(__dirname, "./src"),
		},
	},
	build: {
		rollupOptions: {
			input: {
				main: resolve(__dirname, "index.html"),
				sidepanel: resolve(__dirname, "sidepanel.html"),
				offscreen: resolve(__dirname, "offscreen.html"),
				background: resolve(__dirname, "src/background.ts"),
			},
			output: {
				entryFileNames: "assets/[name].js",
				chunkFileNames: "assets/[name].js",
				assetFileNames: "assets/[name].[ext]",
			},
		},
	},
});

------END OF FILE----

/biome.json:
------BEGIN OF FILE----
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "organizeImports": {
    "enabled": false
  },
  "formatter": {
    "ignore": ["./dist", "./package-lock.json"]
  },
  "linter": {
    "enabled": true,
    "ignore": ["./dist", "./package-lock.json"],
    "rules": {
      "recommended": true
    }
  },
  "json": {
    "parser": {
      "allowComments": true
    },
    "formatter": {
      "enabled": true,
      "indentStyle": "space",
      "indentWidth": 2
    }
  },
  "vcs": {
    "enabled": true,
    "clientKind": "git",
    "useIgnoreFile": true
  }
}

------END OF FILE----

/postcss.config.js:
------BEGIN OF FILE----
export default {
	plugins: {
		tailwindcss: {},
		autoprefixer: {},
	},
};

------END OF FILE----

/src/whisper-worker.d.ts:
------BEGIN OF FILE----
/* eslint-disable @typescript-eslint/no-explicit-any */
export declare module "./whisper-worker.js" {
	export declare function processWhisperMessage(
		audio: Float32Array,
		language: string,
		// biome-ignore lint/suspicious/noExplicitAny: <explanation>
	): Promise<any>;
	export declare function initializeWhisperWorker(
		progressCallbackFunc: (progress: number) => void,
	): Promise<void>;
}

------END OF FILE----

/src/App.tsx:
------BEGIN OF FILE----
import Popup from "./Popup";
import { ThemeProvider } from "./components/theme-provider";
import { Toaster } from "./components/ui/toaster";

function App() {
	return (
		<ThemeProvider storageKey="chrome-extension-transcriptor-theme">
			<Popup />
			<Toaster />
		</ThemeProvider>
	);
}

export default App;

------END OF FILE----

/src/main.tsx:
------BEGIN OF FILE----
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./globals.css";

// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
// biome-ignore lint/style/noNonNullAssertion: <explanation>
ReactDOM.createRoot(document.getElementById("root")!).render(
	<React.StrictMode>
		<App />
	</React.StrictMode>,
);

------END OF FILE----

/src/side-panel.tsx:
------BEGIN OF FILE----
import React from "react";
import ReactDOM from "react-dom/client";
import "./globals.css";
import { ThemeProvider } from "./components/theme-provider";
import { Toaster } from "./components/ui/toaster";
import SidePanelApp from "./side-panel-app";

// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
// biome-ignore lint/style/noNonNullAssertion: <explanation>
ReactDOM.createRoot(document.getElementById("root")!).render(
	<React.StrictMode>
		<ThemeProvider storageKey="chrome-extension-transcriptor-theme">
			<SidePanelApp />
			<Toaster />
		</ThemeProvider>
	</React.StrictMode>,
);

------END OF FILE----

/src/summarizer.ts:
------BEGIN OF FILE----
import { Readability } from "@mozilla/readability";
import TurndownService from "turndown";

export async function summarizeWebPage(language: string): Promise<string> {
	// get current tab content
	console.debug("summarizeWebPage");
	const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
	if (!tab.id) {
		throw new Error("No active tab found");
	}
	const [{ result: content }] = await chrome.scripting.executeScript({
		target: { tabId: tab.id },
		func: () => document.documentElement.outerHTML,
	});
	if (!content) {
		throw new Error("Failed to get content from the active tab");
	}

	// Extract article content using Readability
	const doc = new DOMParser().parseFromString(content, "text/html");
	const reader = new Readability(doc);
	const article = reader.parse();

	if (!article) {
		throw new Error("Failed to extract article content");
	}

	// Convert article content to markdown using Turndown
	const turndownService = new TurndownService();
	const markdown = turndownService.turndown(article.content);

	const markdownLines = markdown.split("\n");

	// extract first N lines to avoid exceeding the input limit
	const maxLength = 40;
	if (markdownLines.length > maxLength) {
		markdownLines.splice(maxLength);
	}

	// Generate summary using Gemini Nano
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	const session = await window.ai.assistant.create({
		systemPrompt:
			"You are helpful assistant to summarize web article. Your output is markdown formatted. please summary with bullet points and meaningful sections.",
		topK: 10,
		temperature: 0,
	});

	const markdownPrompt = markdownLines.join("\n");

	const prompt = `Summarize the following text.:\n\n${markdownPrompt}`;
	console.debug("prompt", prompt);
	let summary = await session.prompt(prompt);
	session.destroy();

	// Translate the summary to Japanese
	console.debug("language", language);
	// initialize session for tlanslation
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	const sessionTranslator = await window.ai.assistant.create({
		systemPrompt: "You are helpful assistant to translate the summary",
		topK: 10,
		temperature: 0,
	});

	if (language === "japanese") {
		summary = await sessionTranslator.prompt(
			`日本語に翻訳してください:\n\n${summary}`,
		);
		console.debug("translated", summary);
	}
	sessionTranslator.destroy();

	console.debug("summary", summary);

	// Add title and URL to the summary
	const titleAndUrl = `# [${tab.title}](${tab.url})\n\n`;
	return titleAndUrl + summary;
}

------END OF FILE----

/src/side-panel-app.tsx:
------BEGIN OF FILE----
// src/side-panel-app.tsx
import { useEffect, useState } from "react";
import { AiSummarizer } from "./components/ai-summarizer";
import { Button } from "./components/ui/button";
import { Textarea } from "./components/ui/textarea";
import { PromptArea } from "./components/PromptArea";
import { useToast } from "./components/ui/use-toast";
import { summarizeWebPage } from "./summarizer";
import { LanguageSelector } from "./components/LanguageSelector";
import { transcriptionSettingsAtom } from "./jotai/settingAtom";
import { useAtom } from "jotai";
import { modelLoadingProgressAtom, modelStatusAtom } from "./jotai/modelStatusAtom";
import { generateResponse } from "../utils/generateResponse";

const SidePanelApp: React.FC = () => {
  const [summary, setSummary] = useState("");
  const [transcriptionSettings, setTranscriptionSettings] = useAtom(transcriptionSettingsAtom);
  const [isSummaryLoading, setIsSummaryLoading] = useState(false);
  const [aiCapabilities, setAiCapabilities] = useState<{ available: string }>({ available: "no" });
  const [transcription, setTranscription] = useState("");
  const [modelStatus, setModelStatus] = useAtom(modelStatusAtom);
  const [loadingProgress, setLoadingProgress] = useAtom(modelLoadingProgressAtom);

  const { toast } = useToast();

  useEffect(() => {
    fetchAiCapabilities().then((capabilities) => {
      setAiCapabilities(capabilities);
    });

    chrome.runtime.onMessage.addListener((message) => {
      if (message.type === "transcript") {
        setTranscription((prev) => `${prev}\n${message.data}`);
      } else if (message.type === "model-status") {
        setModelStatus(message.data.status);
        if (message.data.status === "loading") {
          setLoadingProgress(message.data.progress);
        }
      }
    });
  }, [setModelStatus, setLoadingProgress]);

  const handleSummarize = async () => {
    setIsSummaryLoading(true);
    try {
      const result = await summarizeWebPage(transcriptionSettings.language);
      setSummary(result);
      toast({
        description: "Summarized",
        color: "success",
      });
    } catch (error) {
      console.error(error);
      setSummary(`Failed to summarize: ${error}`);
      toast({
        description: "Failed to summarize",
        color: "error",
      });
    } finally {
      setIsSummaryLoading(false);
    }
  };

  const handleSendPrompt = async (prompt: string) => {
    try {
      const response = await generateResponse(prompt, transcription);
      toast({
        description: response,
        color: "success",
      });
    } catch (error) {
      console.error(error);
      toast({
        description: "Failed to generate response",
        color: "error",
      });
    }
  };

  return (
    <div className="container">
      <div className="box-border">
        <div className="flex flex-col m-1 p-1">
          <h1>Transcription</h1>
          <div className="text-center mt-1">
            <Textarea value={transcription} rows={20} readOnly />
          </div>
          <div className="text-center">
            <h1>Model Status: {modelStatus}</h1>
            {modelStatus === "loading" && <p>{loadingProgress}% loaded</p>}
          </div>
        </div>
        <div className="flex flex-col m-1 p-1">
          <LanguageSelector
            language={transcriptionSettings.language}
            setLanguage={(language) =>
              setTranscriptionSettings((prev) => ({
                ...prev,
                language,
              }))
            }
          />
        </div>
        <div className="flex flex-col m-1 p-1">
          <PromptArea onSendPrompt={handleSendPrompt} />
        </div>
        <div className="flex flex-col m-1 p-1">
          <Button
            onClick={() => {
              navigator.clipboard.writeText(transcription);
              toast({
                description: "Copied to clipboard",
                color: "success",
                duration: 1000,
              });
            }}
          >
            Copy to Clipboard
          </Button>
        </div>
        {aiCapabilities.available === "no" && (
          <div className="flex flex-col m-1 p-1">
            <div className="text-center">
              <h1>AI Summarization is not available</h1>
              <p>
                AI Summarization is not available. Please make sure your chrome
                supports Prompt API.
              </p>
            </div>
          </div>
        )}
        {aiCapabilities.available !== "no" && (
          <AiSummarizer
            setLanguage={(language) =>
              setTranscriptionSettings((prev) => ({
                ...prev,
                language,
              }))
            }
            language={transcriptionSettings.language}
            isSummaryLoading={isSummaryLoading}
            handleSummarize={handleSummarize}
            summary={summary}
          />
        )}
      </div>
    </div>
  );
};

export default SidePanelApp;
------END OF FILE----

/src/index.css:
------BEGIN OF FILE----

------END OF FILE----

/src/background.ts:
------BEGIN OF FILE----
import { createStore } from "jotai";
import {
	initializeWhisperWorker,
	processWhisperMessage,
} from "./whisper-worker.js";
import {
	modelLoadingProgressAtom,
	modelStatusAtom,
} from "./jotai/modelStatusAtom.js";

const store = createStore();

chrome.action.onClicked.addListener(async (tab) => {
	if (tab.id === undefined) {
		console.debug("Tab ID is undefined");
		return;
	}
	console.debug("Tab ID:", tab.id);

	const existingContexts = await chrome.runtime.getContexts({});

	const offscreenDocument = existingContexts.find(
		(c) => c.contextType === "OFFSCREEN_DOCUMENT",
	);

	// If an offscreen document is not already open, create one.
	if (!offscreenDocument) {
		// Create an offscreen document.
		console.debug("creating offscreenDocument");
		await chrome.offscreen.createDocument({
			url: "offscreen.html",
			reasons: [chrome.offscreen.Reason.USER_MEDIA],
			justification: "Recording from chrome.tabCapture API",
		});
	}

	// once the offscreen document is ready, send the stream ID to start recording
	chrome.runtime.onMessage.addListener(async (message) => {
		console.debug("Received message", message);
		if (message.type === "offscreen-ready") {
			console.debug("Received offscreen-ready message");
			// Send the stream ID to the offscreen document to start recording.
			chrome.tabCapture.getMediaStreamId(
				{
					targetTabId: tab.id,
				},
				(streamId) => {
					if (!streamId) {
						console.error("service-worker: Failed to get stream ID");
						return;
					}
					console.debug("Stream ID:", streamId);
					chrome.runtime.sendMessage({
						type: "start-recording",
						target: "offscreen",
						streamId,
					});
					console.debug("Sent start-recording message");
				},
			);
		}
		if (message.type === "initialize-transcription-model") {
			console.debug("Received initialize-transcription-model message");
			await initializeModelLoading();
		}
		if (message.type === "transcription-message") {
			console.debug("Received transcripton message", message);
			const modelStatus = store.get(modelStatusAtom);
			if (modelStatus !== "ready" && modelStatus !== "loading") {
				console.debug("Model is not ready", modelStatus);
				await initializeModelLoading();

				return;
			}
			if (modelStatus === "loading") {
				console.debug("Model is loading");
				return;
			}
			const { serializedAudio, language } = message.data;
			const audio = new Float32Array(JSON.parse(serializedAudio));
			console.debug("audio, language", audio, language);
			const transcripted = (await processWhisperMessage(
				audio,
				language,
			)) as string[];

			chrome.runtime.sendMessage({
				type: "transcript",
				data: {
					transcripted: transcripted.join("\n"),
				},
			});
		}
	});

	console.debug("tab info:", tab);
	console.debug("tab url", tab.url);
});

async function initializeModelLoading() {
	store.set(modelStatusAtom, "loading");
	store.set(modelLoadingProgressAtom, 0);
	chrome.runtime.sendMessage({
		type: "model-status",
		data: {
			status: "loading",
			progress: 0,
		},
	});
	await initializeWhisperWorker((progress) => {
		store.set(modelLoadingProgressAtom, progress);
		chrome.runtime.sendMessage({
			type: "model-status",
			data: {
				status: "loading",
				progress,
			},
		});
	});
	store.set(modelStatusAtom, "ready");
	chrome.runtime.sendMessage({
		type: "model-status",
		data: {
			status: "ready",
		},
	});
}

------END OF FILE----

/src/offscreen.tsx:
------BEGIN OF FILE----
import React from "react";
import { useEffect } from "react";
import ReactDOM from "react-dom/client";
import "./globals.css";
import { useAtom } from "jotai";
import { transcriptionSettingsAtom } from "./jotai/settingAtom";

// https://github.com/huggingface/transformers.js/blob/7a58d6e11968dd85dc87ce37b2ab37213165889a/examples/webgpu-whisper/src/App.jsx
// const IS_WEBGPU_AVAILABLE = !!navigator.gpu;

const WHISPER_SAMPLING_RATE = 16_000;
const MAX_AUDIO_LENGTH = 30; // seconds
const MAX_SAMPLES = WHISPER_SAMPLING_RATE * MAX_AUDIO_LENGTH;

export const Offscreen: React.FC = () => {
	const [transcriptionSettings] = useAtom(transcriptionSettingsAtom);
	const language = transcriptionSettings.language;
	const recorderRef = React.useRef<MediaRecorder | null>(null);
	const [recording, setRecording] = React.useState(false);
	const audioContextRef = React.useRef<AudioContext | null>(null);
	const [chunks, setChunks] = React.useState<Blob[]>([]);

	const setupMediaRecorder = (streamId: string) => {
		if (recorderRef.current) return; // Already set

		navigator.mediaDevices
			.getUserMedia({
				audio: {
					// @ts-expect-error - Chrome-specific properties
					mandatory: {
						chromeMediaSource: "tab",
						chromeMediaSourceId: streamId,
					},
				},
			})
			.then((stream) => {
				console.debug("Setting up media recorder", stream);

				recorderRef.current = new MediaRecorder(stream);
				audioContextRef.current = new AudioContext({
					sampleRate: 16000,
				});

				// Continue to play the captured audio to the user.
				const output = new AudioContext();
				const source = output.createMediaStreamSource(
					recorderRef.current.stream,
				);
				source.connect(output.destination);

				recorderRef.current.onstart = () => {
					setRecording(true);
					setChunks([]);
				};
				recorderRef.current.ondataavailable = (e) => {
					if (e.data.size > 0) {
						console.debug("Received chunk", e.data);
						setChunks((prev) => [...prev, e.data]);

						// requestData after 25 seconds
						setTimeout(() => {
							if (recorderRef.current) recorderRef.current.requestData();
						}, 10 * 1000);
					} else {
						// Empty chunk received, so we request new data after a short timeout
						console.debug("Empty chunk received");
						setTimeout(() => {
							if (recorderRef.current) recorderRef.current.requestData();
						}, 25);
					}
				};

				recorderRef.current.onstop = () => {
					setRecording(false);
				};
				recorderRef.current.start();
			})
			.catch((err) => console.error("The following error occurred: ", err));
	};

	// transcription
	useEffect(() => {
		if (!recorderRef.current) return;
		if (!recording) return;

		if (chunks.length > 0) {
			// Generate from data
			const blob = new Blob(chunks, { type: recorderRef.current.mimeType });

			const fileReader = new FileReader();

			fileReader.onloadend = async () => {
				const arrayBuffer = fileReader.result;
				if (audioContextRef.current === null) {
					console.debug("Audio context is null");
					return;
				}
				if (!arrayBuffer) {
					console.debug("Array buffer is null");
					return;
				}
				if (!(arrayBuffer instanceof ArrayBuffer)) {
					console.debug("Array buffer is not an ArrayBuffer");
					return;
				}
				const decoded =
					await audioContextRef.current.decodeAudioData(arrayBuffer);
				let audio = decoded.getChannelData(0);
				if (audio.length > MAX_SAMPLES) {
					// Get last MAX_SAMPLES
					audio = audio.slice(-MAX_SAMPLES);
				}
				console.debug("Decoded audio", audio);

				const serializedAudio = JSON.stringify(Array.from(audio));

				// worker.current.postMessage({
				//   type: "generate",
				//   data: { audio, language },
				// });
				chrome.runtime.sendMessage({
					type: "transcription-message",
					data: {
						type: "generate",
						serializedAudio: serializedAudio,
						// model: "Xenova/whisper-tiny",
						// multilingual: true,
						// quantized: false,
						// subtask: "transcribe",
						language: language,
					},
				});
			};
			fileReader.readAsArrayBuffer(blob);
		} else {
			recorderRef.current?.requestData();
		}
	}, [recording, chunks, language]);

	const setupTriggeredRef = React.useRef(false);
	const setupOffscreen = () => {
		if (setupTriggeredRef.current) return;
		setupTriggeredRef.current = true;
		console.debug("Setting up offscreen script");
		chrome.runtime.onMessage.addListener(async (message) => {
			if (message.target !== "offscreen") return;
			console.debug("Received message", message);

			if (message.type === "start-recording") {
				console.debug("Received start-recording message", message.streamId);
				setupMediaRecorder(message.streamId);
			}
		});

		// send offscreen ready message
		chrome.runtime.sendMessage({
			type: "offscreen-ready",
		});
	};

	useEffect(() => {
		setupOffscreen();
	});
	return (
		<div>
			<h1>Offscreen</h1>
			{/* mic permission button */}
		</div>
	);
};

// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
// biome-ignore lint/style/noNonNullAssertion: <explanation>
ReactDOM.createRoot(document.getElementById("root")!).render(
	<React.StrictMode>
		<Offscreen />
	</React.StrictMode>,
);

------END OF FILE----

/src/vite-env.d.ts:
------BEGIN OF FILE----
/// <reference types="vite/client" />

------END OF FILE----

/src/whisper-worker.js:
------BEGIN OF FILE----
/* eslint-disable no-undef */
/* eslint-disable @typescript-eslint/no-unused-vars */
import {
	AutoProcessor,
	AutoTokenizer,
	TextStreamer,
	WhisperForConditionalGeneration,
	full,
} from "@huggingface/transformers";

const MAX_NEW_TOKENS = 64;

/**
 * This class uses the Singleton pattern to ensure that only one instance of the model is loaded.
 */

// biome-ignore lint/complexity/noStaticOnlyClass: <explanation>
class AutomaticSpeechRecognitionPipeline {
	static model_id = null;
	static tokenizer = null;
	static processor = null;
	static model = null;

	static async getInstance(progress_callback = null) {
		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		this.model_id = "onnx-community/whisper-large-v3-turbo";
		// this.model_id = "onnx-community/whisper-base";

		AutomaticSpeechRecognitionPipeline;
		AutomaticSpeechRecognitionPipeline.tokenizer ??=
			// biome-ignore lint/complexity/noThisInStatic: <explanation>
			AutoTokenizer.from_pretrained(this.model_id, {
				progress_callback,
			});
		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		this.processor ??= AutoProcessor.from_pretrained(this.model_id, {
			progress_callback,
		});

		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		this.model ??= WhisperForConditionalGeneration.from_pretrained(
			// biome-ignore lint/complexity/noThisInStatic: <explanation>
			this.model_id,
			{
				dtype: {
					encoder_model: "fp16", // 'fp16' works too
					decoder_model_merged: "q4", // or 'fp32' ('fp16' is broken)
				},
				device: "webgpu",
				progress_callback,
			},
		);
		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		return Promise.all([this.tokenizer, this.processor, this.model]);
	}
}

let processing = false;
export async function processWhisperMessage(audio, language) {
	if (processing) return;
	processing = true;
	if (!audio) {
		console.debug("No audio data provided.");
		processing = false;
		return;
	}
	console.debug("processWhisperMessage", audio, language);
	// const audioF32 = new Float32Array(audio);
	// console.debug("audio", audioF32);

	// Tell the main thread we are starting
	// self.postMessage({ status: "start" });

	// Retrieve the text-generation pipeline.
	const [tokenizer, processor, model] =
		await AutomaticSpeechRecognitionPipeline.getInstance((data) => {
			// We also add a progress callback to the pipeline so that we can
			// track model loading.
			if (
				data.status === "progress" &&
				Math.ceil(data.progress * 100) % 10 === 0
			) {
				console.debug(`Model loading: ${data.progress}%`);
				chrome.runtime.sendMessage({ type: "whisper-progress", data });
			}
			// self.postMessage(data);
		});

	let startTime;
	let numTokens = 0;
	const callback_function = (output) => {
		startTime ??= performance.now();

		let tps;
		if (numTokens++ > 0) {
			tps = (numTokens / (performance.now() - startTime)) * 1000;
		}
		console.debug("callback_func/output", output);
		// self.postMessage({
		//   status: "update",
		//   output,
		//   tps,
		//   numTokens,
		// });
	};

	const streamer = new TextStreamer(tokenizer, {
		skip_prompt: true,
		skip_special_tokens: true,
		callback_function,
	});

	const inputs = await processor(audio);

	const outputs = await model.generate({
		...inputs,
		max_new_tokens: MAX_NEW_TOKENS,
		language,
		streamer,
	});

	const outputText = tokenizer.batch_decode(outputs, {
		skip_special_tokens: true,
	});

	// Send the output back to the main thread
	console.debug("outputText", outputText);
	processing = false;
	return outputText;
}

export async function initializeWhisperWorker(progress_callback) {
	// Load the pipeline and save it for future use.
	const [tokenizer, processor, model] =
		await AutomaticSpeechRecognitionPipeline.getInstance((data) => {
			// We also add a progress callback to the pipeline so that we can
			// track model loading.
			console.debug("data", data);
			if (
				data.status === "progress" &&
				Math.ceil(data.progress * 100) % 10 === 0
			) {
				console.debug(`Model loading: ${data.progress}%`);
				progress_callback(data.progress);
			}
			// self.postMessage(data);
		});

	// Run model with dummy input to compile shaders
	await model.generate({
		input_features: full([1, 128, 3000], 0.0),
		max_new_tokens: 1,
	});
}

------END OF FILE----

/src/Popup.tsx:
------BEGIN OF FILE----
import type React from "react";
import { useEffect, useState } from "react";
import { AiSummarizer } from "./components/ai-summarizer";
import { Textarea } from "./components/ui/textarea";
import { useToast } from "./components/ui/use-toast";
import { summarizeWebPage } from "./summarizer";

const getDefaultLanguage = () => {
	const browserLocale = navigator.language;
	if (browserLocale.startsWith("ja")) {
		return "japanese";
	}
	return "english";
};

const fetchAiCapabilities = async () => {
	if (!window.ai) {
		return {
			available: "no",
		};
	}

	const { available } = await window.ai.languageModel.capabilities();

	return {
		available,
	};
};

const Popup: React.FC = () => {
	const [summary, setSummary] = useState("");
	const [language, setLanguage] = useState(getDefaultLanguage());
	const [isSummaryLoading, setIsSummaryLoading] = useState(false);
	const [aiCapabilities, setAiCapabilities] = useState<{ available: string }>({
		available: "no",
	});
	const [transcription, setTranscription] = useState("");

	useEffect(() => {
		fetchAiCapabilities().then((capabilities) => {
			setAiCapabilities(capabilities);
		});

		chrome.runtime.onMessage.addListener((message) => {
			if (message.type === "transcript") {
				setTranscription((prev) => `${prev}\n${message.data}`);
			}
		});
	}, []);

	const { toast } = useToast();

	const handleSummarize = async () => {
		setIsSummaryLoading(true);
		try {
			const result = await summarizeWebPage(language);
			setSummary(result);
			toast({
				description: "Summarized",
				color: "success",
			});
		} catch (error) {
			console.error(error);
			setSummary(`Failed to summarize: ${error}`);
			toast({
				description: "Failed to summarize",
				color: "error",
			});
		} finally {
			setIsSummaryLoading(false);
		}
	};

	return (
		<div className="container">
			<div className="box-border h-auto w-[400px]">
				{/* Transcription from web speech api */}
				<div className="flex flex-col m-1 p-1">
					<div className="text-center">
						<h1>Transcription</h1>
						<Textarea value={transcription} rows={10} readOnly />
					</div>
				</div>

				{aiCapabilities.available === "no" && (
					<div className="flex flex-col m-1 p-1">
						<div className="text-center">
							<h1>AI Summarization is not available</h1>
							<p>
								AI Summarization is not available. Please make sure your chrome
								supports Prompt API.
							</p>
						</div>
					</div>
				)}
				{aiCapabilities.available !== "no" && (
					<AiSummarizer
						setLanguage={setLanguage}
						language={language}
						isSummaryLoading={isSummaryLoading}
						handleSummarize={handleSummarize}
						summary={summary}
					/>
				)}
			</div>
		</div>
	);
};

export default Popup;

------END OF FILE----

/src/globals.css:
------BEGIN OF FILE----
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	:root {
		--background: 0 0% 100%;
		--foreground: 240 10% 3.9%;

		--card: 0 0% 100%;
		--card-foreground: 240 10% 3.9%;

		--popover: 0 0% 100%;
		--popover-foreground: 240 10% 3.9%;

		--primary: 240 5.9% 10%;
		--primary-foreground: 0 0% 98%;

		--secondary: 240 4.8% 95.9%;
		--secondary-foreground: 240 5.9% 10%;

		--muted: 240 4.8% 95.9%;
		--muted-foreground: 240 3.8% 46.1%;

		--accent: 240 4.8% 95.9%;
		--accent-foreground: 240 5.9% 10%;

		--destructive: 0 84.2% 60.2%;
		--destructive-foreground: 0 0% 98%;

		--border: 240 5.9% 90%;
		--input: 240 5.9% 90%;
		--ring: 240 10% 3.9%;

		--radius: 0.5rem;
	}

	.dark {
		--background: 240 10% 3.9%;
		--foreground: 0 0% 98%;

		--card: 240 10% 3.9%;
		--card-foreground: 0 0% 98%;

		--popover: 240 10% 3.9%;
		--popover-foreground: 0 0% 98%;

		--primary: 0 0% 98%;
		--primary-foreground: 240 5.9% 10%;

		--secondary: 240 3.7% 15.9%;
		--secondary-foreground: 0 0% 98%;

		--muted: 240 3.7% 15.9%;
		--muted-foreground: 240 5% 64.9%;

		--accent: 240 3.7% 15.9%;
		--accent-foreground: 0 0% 98%;

		--destructive: 0 62.8% 30.6%;
		--destructive-foreground: 0 0% 98%;

		--border: 240 3.7% 15.9%;
		--input: 240 3.7% 15.9%;
		--ring: 240 4.9% 83.9%;
	}
}

@layer base {
	* {
		@apply border-border;
	}
	body {
		@apply bg-background text-foreground;
	}
}

------END OF FILE----

/src/utils/generateResponse.ts:
------BEGIN OF FILE----
// src/utils/generateResponse.ts
import { AutoTokenizer, AutoModelForCausalLM } from "@huggingface/transformers";

export async function generateResponse(prompt: string, transcript: string): Promise<string> {
  const tokenizer = await AutoTokenizer.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");
  const model = await AutoModelForCausalLM.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");

  const inputText = `${prompt}\n${transcript}`;
  const inputs = tokenizer.encode(inputText, { return_tensors: "pt" });

  const output = await model.generate(inputs, { max_length: 500 });
  const response = tokenizer.decode(output[0], { skip_special_tokens: true });

  return response;
}
------END OF FILE----

/src/components/theme-provider.tsx:
------BEGIN OF FILE----
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
	children: React.ReactNode;
	defaultTheme?: Theme;
	storageKey?: string;
};

type ThemeProviderState = {
	theme: Theme;
	setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
	theme: "system",
	setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
	children,
	defaultTheme = "system",
	storageKey = "vite-ui-theme",
	...props
}: ThemeProviderProps) {
	const [theme, setTheme] = useState<Theme>(
		() => (localStorage.getItem(storageKey) as Theme) || defaultTheme,
	);

	useEffect(() => {
		const root = window.document.documentElement;

		root.classList.remove("light", "dark");

		if (theme === "system") {
			const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
				.matches
				? "dark"
				: "light";

			root.classList.add(systemTheme);
			return;
		}

		root.classList.add(theme);
	}, [theme]);

	const value = {
		theme,
		setTheme: (theme: Theme) => {
			localStorage.setItem(storageKey, theme);
			setTheme(theme);
		},
	};

	return (
		<ThemeProviderContext.Provider {...props} value={value}>
			{children}
		</ThemeProviderContext.Provider>
	);
}

export const useTheme = () => {
	const context = useContext(ThemeProviderContext);

	if (context === undefined)
		throw new Error("useTheme must be used within a ThemeProvider");

	return context;
};

------END OF FILE----

/src/components/LanguageSelector.tsx:
------BEGIN OF FILE----
import type React from "react";
import * as Select from "@radix-ui/react-select";
import { ChevronDownIcon, ChevronUpIcon } from "@radix-ui/react-icons";
import { LANGUAGES, type TranscriptionLanguage } from "@/jotai/settingAtom";

export const LanguageSelector: React.FC<{
	language: TranscriptionLanguage;
	setLanguage: (language: TranscriptionLanguage) => void;
}> = ({ language, setLanguage }) => {
	const handleLanguageChange = (value: string) => {
		setLanguage(value as TranscriptionLanguage);
	};

	const names = Object.values(LANGUAGES);

	return (
		<Select.Root onValueChange={handleLanguageChange} defaultValue={language}>
			<Select.Trigger className="inline-flex h-[35px] items-center justify-center gap-[5px] rounded px-[15px] text-[13px] leading-none outline-none hover:bg-mauve3 focus:shadow-[0_0_0_2px]">
				<Select.Value
					placeholder="Select a language…"
					defaultValue={language}
				/>
				<Select.Icon>
					<ChevronDownIcon />
				</Select.Icon>
			</Select.Trigger>
			<Select.Portal>
				<Select.Content className="overflow-hidden rounded-md bg-black shadow-[0px_10px_38px_-10px_rgba(22,_23,_24,_0.35),0px_10px_20px_-15px_rgba(22,_23,_24,_0.2)]">
					<Select.ScrollUpButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronUpIcon />
					</Select.ScrollUpButton>
					<Select.Viewport className="p-[5px]">
						<Select.Group>
							<Select.Label className="px-[25px] text-xs leading-[25px]">
								Languages
							</Select.Label>
							{names.map((name) => (
								<SelectItem key={name} value={name}>
									{name}
								</SelectItem>
							))}
						</Select.Group>
					</Select.Viewport>
					<Select.ScrollDownButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronDownIcon />
					</Select.ScrollDownButton>
				</Select.Content>
			</Select.Portal>
		</Select.Root>
	);
};

interface SelectItemProps {
	children: React.ReactNode;
	value: string;
}

const SelectItem: React.FC<SelectItemProps> = ({ children, ...props }) => {
	return (
		<Select.Item
			{...props}
			className="relative flex h-[25px] select-none items-center px-[25px] text-[13px] leading-none data-[highlighted]:bg-violet9 data-[highlighted]:text-violet1"
		>
			<Select.ItemText>{children}</Select.ItemText>
		</Select.Item>
	);
};

------END OF FILE----

/src/components/PromptArea.tsx:
------BEGIN OF FILE----
// src/components/PromptArea.tsx
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { SendIcon } from "lucide-react";

interface PromptAreaProps {
  onSendPrompt: (prompt: string) => void;
}

export const PromptArea: React.FC<PromptAreaProps> = ({ onSendPrompt }) => {
  const [prompt, setPrompt] = useState("");

  const handleSendPrompt = () => {
    if (prompt.trim() !== "") {
      onSendPrompt(prompt);
      setPrompt("");
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <Textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        rows={4}
        placeholder="Enter your prompt here..."
      />
      <Button onClick={handleSendPrompt}>
        <SendIcon className="mr-2 h-4 w-4" /> Send
      </Button>
    </div>
  );
};
------END OF FILE----

/src/components/ai-summarizer.tsx:
------BEGIN OF FILE----
import { Label } from "@radix-ui/react-label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "@radix-ui/react-select";
import { Loader2 } from "lucide-react";
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { toast } from "./ui/use-toast";
import type { TranscriptionLanguage } from "@/jotai/settingAtom";

interface AiSummarizerProps {
	setLanguage: (e: TranscriptionLanguage) => void;
	language: string;
	isSummaryLoading: boolean;
	handleSummarize: () => Promise<void>;
	summary: string;
}

export const AiSummarizer: React.FC<AiSummarizerProps> = ({
	setLanguage,
	language,
	isSummaryLoading,
	handleSummarize,
	summary,
}) => {
	return (
		<div className="flex flex-col m-1 p-1">
			<div className="flex flex-row my-1 justify">
				<div className="basis-1/2">
					<div>
						<Label htmlFor="language">Summarization Language</Label>
						<Select
							onValueChange={(e) => {
								setLanguage(e as TranscriptionLanguage);
							}}
							defaultValue={language}
						>
							<SelectTrigger className="w-[180px]">
								<SelectValue
									placeholder="Select Language"
									defaultValue={language}
								/>
							</SelectTrigger>
							<SelectContent defaultValue={language} id="language">
								<SelectItem value="english">English</SelectItem>
								<SelectItem value="japanese">Japanese</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</div>
				<div className="basis-1/2 flex flex-col justify-end items-end my-1">
					{isSummaryLoading ? (
						<Button disabled variant={"outline"}>
							<Loader2 className="mr-2 h-4 w-4 animate-spin" />
							Summarizing...
						</Button>
					) : (
						<Button onClick={handleSummarize}>
							Summarize This Transcription
						</Button>
					)}
				</div>
			</div>
			<div className="basis-1/1 grid w-full gap-2">
				<Textarea value={summary} rows={10} readOnly />
				<Button
					variant={"outline"}
					onClick={() => {
						navigator.clipboard.writeText(summary).then(() => {
							toast({
								description: "Copied to clipboard",
							});
						});
					}}
				>
					Copy to Clipboard
				</Button>
			</div>
		</div>
	);
};

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/hooks/useTranscriber.ts:
------BEGIN OF FILE----
/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-unused-vars */
// https://github.com/xenova/whisper-web/blob/main/src/hooks/useTranscriber.ts
// import { useCallback, useMemo, useState } from "react";

// interface ProgressItem {
//   file: string;
//   loaded: number;
//   progress: number;
//   total: number;
//   name: string;
//   status: string;
// }

// interface TranscriberUpdateData {
//   data: [
//     string,
//     { chunks: { text: string; timestamp: [number, number | null] }[] }
//   ];
//   text: string;
// }

// interface TranscriberCompleteData {
//   data: {
//     text: string;
//     chunks: { text: string; timestamp: [number, number | null] }[];
//   };
// }

// export interface TranscriberData {
//   isBusy: boolean;
//   text: string;
//   chunks: { text: string; timestamp: [number, number | null] }[];
// }

// export interface Transcriber {
//   onInputChange: () => void;
//   isBusy: boolean;
//   isModelLoading: boolean;
//   progressItems: ProgressItem[];
//   start: (audioData: AudioBuffer | undefined) => void;
//   output?: TranscriberData;
//   model: string;
//   setModel: (model: string) => void;
//   multilingual: boolean;
//   setMultilingual: (model: boolean) => void;
//   quantized: boolean;
//   setQuantized: (model: boolean) => void;
//   subtask: string;
//   setSubtask: (subtask: string) => void;
//   language?: string;
//   setLanguage: (language: string) => void;
// }

// export function useTranscriber(): Transcriber {
//   const [transcript, setTranscript] = useState<TranscriberData | undefined>(
//     undefined
//   );
//   const [isBusy, setIsBusy] = useState(false);
//   const [isModelLoading, setIsModelLoading] = useState(false);

//   const [progressItems, setProgressItems] = useState<ProgressItem[]>([]);

//   const [model, setModel] = useState<string>(Constants.DEFAULT_MODEL);
//   const [subtask, setSubtask] = useState<string>(Constants.DEFAULT_SUBTASK);
//   const [quantized, setQuantized] = useState<boolean>(false);
//   const [multilingual, setMultilingual] = useState<boolean>(
//     Constants.DEFAULT_MULTILINGUAL
//   );
//   const [language, setLanguage] = useState<string>(Constants.DEFAULT_LANGUAGE);

//   const onInputChange = useCallback(() => {
//     setTranscript(undefined);
//   }, []);

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const postRequest = useCallback(
//     async (audioData: AudioBuffer | undefined) => {
//       if (audioData) {
//         setTranscript(undefined);
//         setIsBusy(true);

//         // biome-ignore lint/suspicious/noImplicitAnyLet: <explanation>
//         let audio;
//         if (audioData.numberOfChannels === 2) {
//           const SCALING_FACTOR = Math.sqrt(2);

//           const left = audioData.getChannelData(0);
//           const right = audioData.getChannelData(1);

//           audio = new Float32Array(left.length);
//           for (let i = 0; i < audioData.length; ++i) {
//             audio[i] = (SCALING_FACTOR * (left[i] + right[i])) / 2;
//           }
//         } else {
//           // If the audio is not stereo, we can just use the first channel:
//           audio = audioData.getChannelData(0);
//         }

//         // webWorker.postMessage({
//         //   audio,
//         //   model,
//         //   multilingual,
//         //   quantized,
//         //   subtask: multilingual ? subtask : null,
//         //   language: multilingual && language !== "auto" ? language : null,
//         // });
//       }
//     },
//     [model, multilingual, quantized, subtask, language]
//   );

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const transcriber = useMemo(() => {
//     return {
//       onInputChange,
//       isBusy,
//       isModelLoading,
//       progressItems,
//       start: postRequest,
//       output: transcript,
//       model,
//       setModel,
//       multilingual,
//       setMultilingual,
//       quantized,
//       setQuantized,
//       subtask,
//       setSubtask,
//       language,
//       setLanguage,
//     };
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [
//     isBusy,
//     isModelLoading,
//     progressItems,
//     postRequest,
//     transcript,
//     model,
//     multilingual,
//     quantized,
//     subtask,
//     language,
//   ]);

//   return transcriber;
// }

// const Constants = {
//   SAMPLING_RATE: 16000,
//   DEFAULT_MODEL: "Xenova/whisper-tiny",
//   DEFAULT_SUBTASK: "transcribe",
//   DEFAULT_LANGUAGE: "english",
//   DEFAULT_MULTILINGUAL: false,
// };

------END OF FILE----

/src/lib/utils.ts:
------BEGIN OF FILE----
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

------END OF FILE----

/src/jotai/modelStatusAtom.ts:
------BEGIN OF FILE----
// transcription model state

import { atom } from "jotai";

export type ModelStatus = "unknown" | "loading" | "ready" | "error";

export const modelStatusAtom = atom<ModelStatus>("unknown");
export const modelLoadingProgressAtom = atom<number>(0);
export type transcriptionModelName =
	| "onnx-community/whisper-base"
	| "onnx-community/whisper-large-turbo-v3";
export const transcriptionModelAtom = atom<transcriptionModelName>(
	"onnx-community/whisper-large-turbo-v3",
);

------END OF FILE----

/src/jotai/settingAtom.ts:
------BEGIN OF FILE----
import { atomWithStorage } from "jotai/utils";

export type TranscriptionModel = "onnx-community/whisper-base";

// List of supported languages:
// https://help.openai.com/en/articles/7031512-whisper-api-faq
// https://github.com/openai/whisper/blob/248b6cb124225dd263bb9bd32d060b6517e067f8/whisper/tokenizer.py#L79
export const LANGUAGES = {
	en: "english",
	zh: "chinese",
	de: "german",
	es: "spanish/castilian",
	ru: "russian",
	ko: "korean",
	fr: "french",
	ja: "japanese",
	pt: "portuguese",
	tr: "turkish",
	pl: "polish",
	ca: "catalan/valencian",
	nl: "dutch/flemish",
	ar: "arabic",
	sv: "swedish",
	it: "italian",
	id: "indonesian",
	hi: "hindi",
	fi: "finnish",
	vi: "vietnamese",
	he: "hebrew",
	uk: "ukrainian",
	el: "greek",
	ms: "malay",
	cs: "czech",
	ro: "romanian/moldavian/moldovan",
	da: "danish",
	hu: "hungarian",
	ta: "tamil",
	no: "norwegian",
	th: "thai",
	ur: "urdu",
	hr: "croatian",
	bg: "bulgarian",
	lt: "lithuanian",
	la: "latin",
	mi: "maori",
	ml: "malayalam",
	cy: "welsh",
	sk: "slovak",
	te: "telugu",
	fa: "persian",
	lv: "latvian",
	bn: "bengali",
	sr: "serbian",
	az: "azerbaijani",
	sl: "slovenian",
	kn: "kannada",
	et: "estonian",
	mk: "macedonian",
	br: "breton",
	eu: "basque",
	is: "icelandic",
	hy: "armenian",
	ne: "nepali",
	mn: "mongolian",
	bs: "bosnian",
	kk: "kazakh",
	sq: "albanian",
	sw: "swahili",
	gl: "galician",
	mr: "marathi",
	pa: "punjabi/panjabi",
	si: "sinhala/sinhalese",
	km: "khmer",
	sn: "shona",
	yo: "yoruba",
	so: "somali",
	af: "afrikaans",
	oc: "occitan",
	ka: "georgian",
	be: "belarusian",
	tg: "tajik",
	sd: "sindhi",
	gu: "gujarati",
	am: "amharic",
	yi: "yiddish",
	lo: "lao",
	uz: "uzbek",
	fo: "faroese",
	ht: "haitian creole/haitian",
	ps: "pashto/pushto",
	tk: "turkmen",
	nn: "nynorsk",
	mt: "maltese",
	sa: "sanskrit",
	lb: "luxembourgish/letzeburgesch",
	my: "myanmar/burmese",
	bo: "tibetan",
	tl: "tagalog",
	mg: "malagasy",
	as: "assamese",
	tt: "tatar",
	haw: "hawaiian",
	ln: "lingala",
	ha: "hausa",
	ba: "bashkir",
	jw: "javanese",
	su: "sundanese",
} as const;

// language set to union of values of LANGUAGES
export type TranscriptionLanguage = (typeof LANGUAGES)[keyof typeof LANGUAGES];

export type TranscriptionSettings = {
	language: TranscriptionLanguage;
};

export const transcriptionSettingsAtom = atomWithStorage<TranscriptionSettings>(
	"transcriptionSettings",
	{
		language: "english" as TranscriptionLanguage,
	},
);

------END OF FILE----

/src/utils/generateResponse.ts:
------BEGIN OF FILE----
// src/utils/generateResponse.ts
import { AutoTokenizer, AutoModelForCausalLM } from "@huggingface/transformers";

export async function generateResponse(prompt: string, transcript: string): Promise<string> {
  const tokenizer = await AutoTokenizer.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");
  const model = await AutoModelForCausalLM.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");

  const inputText = `${prompt}\n${transcript}`;
  const inputs = tokenizer.encode(inputText, { return_tensors: "pt" });

  const output = await model.generate(inputs, { max_length: 500 });
  const response = tokenizer.decode(output[0], { skip_special_tokens: true });

  return response;
}
------END OF FILE----

/src/components/theme-provider.tsx:
------BEGIN OF FILE----
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
	children: React.ReactNode;
	defaultTheme?: Theme;
	storageKey?: string;
};

type ThemeProviderState = {
	theme: Theme;
	setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
	theme: "system",
	setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
	children,
	defaultTheme = "system",
	storageKey = "vite-ui-theme",
	...props
}: ThemeProviderProps) {
	const [theme, setTheme] = useState<Theme>(
		() => (localStorage.getItem(storageKey) as Theme) || defaultTheme,
	);

	useEffect(() => {
		const root = window.document.documentElement;

		root.classList.remove("light", "dark");

		if (theme === "system") {
			const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
				.matches
				? "dark"
				: "light";

			root.classList.add(systemTheme);
			return;
		}

		root.classList.add(theme);
	}, [theme]);

	const value = {
		theme,
		setTheme: (theme: Theme) => {
			localStorage.setItem(storageKey, theme);
			setTheme(theme);
		},
	};

	return (
		<ThemeProviderContext.Provider {...props} value={value}>
			{children}
		</ThemeProviderContext.Provider>
	);
}

export const useTheme = () => {
	const context = useContext(ThemeProviderContext);

	if (context === undefined)
		throw new Error("useTheme must be used within a ThemeProvider");

	return context;
};

------END OF FILE----

/src/components/LanguageSelector.tsx:
------BEGIN OF FILE----
import type React from "react";
import * as Select from "@radix-ui/react-select";
import { ChevronDownIcon, ChevronUpIcon } from "@radix-ui/react-icons";
import { LANGUAGES, type TranscriptionLanguage } from "@/jotai/settingAtom";

export const LanguageSelector: React.FC<{
	language: TranscriptionLanguage;
	setLanguage: (language: TranscriptionLanguage) => void;
}> = ({ language, setLanguage }) => {
	const handleLanguageChange = (value: string) => {
		setLanguage(value as TranscriptionLanguage);
	};

	const names = Object.values(LANGUAGES);

	return (
		<Select.Root onValueChange={handleLanguageChange} defaultValue={language}>
			<Select.Trigger className="inline-flex h-[35px] items-center justify-center gap-[5px] rounded px-[15px] text-[13px] leading-none outline-none hover:bg-mauve3 focus:shadow-[0_0_0_2px]">
				<Select.Value
					placeholder="Select a language…"
					defaultValue={language}
				/>
				<Select.Icon>
					<ChevronDownIcon />
				</Select.Icon>
			</Select.Trigger>
			<Select.Portal>
				<Select.Content className="overflow-hidden rounded-md bg-black shadow-[0px_10px_38px_-10px_rgba(22,_23,_24,_0.35),0px_10px_20px_-15px_rgba(22,_23,_24,_0.2)]">
					<Select.ScrollUpButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronUpIcon />
					</Select.ScrollUpButton>
					<Select.Viewport className="p-[5px]">
						<Select.Group>
							<Select.Label className="px-[25px] text-xs leading-[25px]">
								Languages
							</Select.Label>
							{names.map((name) => (
								<SelectItem key={name} value={name}>
									{name}
								</SelectItem>
							))}
						</Select.Group>
					</Select.Viewport>
					<Select.ScrollDownButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronDownIcon />
					</Select.ScrollDownButton>
				</Select.Content>
			</Select.Portal>
		</Select.Root>
	);
};

interface SelectItemProps {
	children: React.ReactNode;
	value: string;
}

const SelectItem: React.FC<SelectItemProps> = ({ children, ...props }) => {
	return (
		<Select.Item
			{...props}
			className="relative flex h-[25px] select-none items-center px-[25px] text-[13px] leading-none data-[highlighted]:bg-violet9 data-[highlighted]:text-violet1"
		>
			<Select.ItemText>{children}</Select.ItemText>
		</Select.Item>
	);
};

------END OF FILE----

/src/components/PromptArea.tsx:
------BEGIN OF FILE----
// src/components/PromptArea.tsx
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { SendIcon } from "lucide-react";

interface PromptAreaProps {
  onSendPrompt: (prompt: string) => void;
}

export const PromptArea: React.FC<PromptAreaProps> = ({ onSendPrompt }) => {
  const [prompt, setPrompt] = useState("");

  const handleSendPrompt = () => {
    if (prompt.trim() !== "") {
      onSendPrompt(prompt);
      setPrompt("");
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <Textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        rows={4}
        placeholder="Enter your prompt here..."
      />
      <Button onClick={handleSendPrompt}>
        <SendIcon className="mr-2 h-4 w-4" /> Send
      </Button>
    </div>
  );
};
------END OF FILE----

/src/components/ai-summarizer.tsx:
------BEGIN OF FILE----
import { Label } from "@radix-ui/react-label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "@radix-ui/react-select";
import { Loader2 } from "lucide-react";
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { toast } from "./ui/use-toast";
import type { TranscriptionLanguage } from "@/jotai/settingAtom";

interface AiSummarizerProps {
	setLanguage: (e: TranscriptionLanguage) => void;
	language: string;
	isSummaryLoading: boolean;
	handleSummarize: () => Promise<void>;
	summary: string;
}

export const AiSummarizer: React.FC<AiSummarizerProps> = ({
	setLanguage,
	language,
	isSummaryLoading,
	handleSummarize,
	summary,
}) => {
	return (
		<div className="flex flex-col m-1 p-1">
			<div className="flex flex-row my-1 justify">
				<div className="basis-1/2">
					<div>
						<Label htmlFor="language">Summarization Language</Label>
						<Select
							onValueChange={(e) => {
								setLanguage(e as TranscriptionLanguage);
							}}
							defaultValue={language}
						>
							<SelectTrigger className="w-[180px]">
								<SelectValue
									placeholder="Select Language"
									defaultValue={language}
								/>
							</SelectTrigger>
							<SelectContent defaultValue={language} id="language">
								<SelectItem value="english">English</SelectItem>
								<SelectItem value="japanese">Japanese</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</div>
				<div className="basis-1/2 flex flex-col justify-end items-end my-1">
					{isSummaryLoading ? (
						<Button disabled variant={"outline"}>
							<Loader2 className="mr-2 h-4 w-4 animate-spin" />
							Summarizing...
						</Button>
					) : (
						<Button onClick={handleSummarize}>
							Summarize This Transcription
						</Button>
					)}
				</div>
			</div>
			<div className="basis-1/1 grid w-full gap-2">
				<Textarea value={summary} rows={10} readOnly />
				<Button
					variant={"outline"}
					onClick={() => {
						navigator.clipboard.writeText(summary).then(() => {
							toast({
								description: "Copied to clipboard",
							});
						});
					}}
				>
					Copy to Clipboard
				</Button>
			</div>
		</div>
	);
};

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/hooks/useTranscriber.ts:
------BEGIN OF FILE----
/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-unused-vars */
// https://github.com/xenova/whisper-web/blob/main/src/hooks/useTranscriber.ts
// import { useCallback, useMemo, useState } from "react";

// interface ProgressItem {
//   file: string;
//   loaded: number;
//   progress: number;
//   total: number;
//   name: string;
//   status: string;
// }

// interface TranscriberUpdateData {
//   data: [
//     string,
//     { chunks: { text: string; timestamp: [number, number | null] }[] }
//   ];
//   text: string;
// }

// interface TranscriberCompleteData {
//   data: {
//     text: string;
//     chunks: { text: string; timestamp: [number, number | null] }[];
//   };
// }

// export interface TranscriberData {
//   isBusy: boolean;
//   text: string;
//   chunks: { text: string; timestamp: [number, number | null] }[];
// }

// export interface Transcriber {
//   onInputChange: () => void;
//   isBusy: boolean;
//   isModelLoading: boolean;
//   progressItems: ProgressItem[];
//   start: (audioData: AudioBuffer | undefined) => void;
//   output?: TranscriberData;
//   model: string;
//   setModel: (model: string) => void;
//   multilingual: boolean;
//   setMultilingual: (model: boolean) => void;
//   quantized: boolean;
//   setQuantized: (model: boolean) => void;
//   subtask: string;
//   setSubtask: (subtask: string) => void;
//   language?: string;
//   setLanguage: (language: string) => void;
// }

// export function useTranscriber(): Transcriber {
//   const [transcript, setTranscript] = useState<TranscriberData | undefined>(
//     undefined
//   );
//   const [isBusy, setIsBusy] = useState(false);
//   const [isModelLoading, setIsModelLoading] = useState(false);

//   const [progressItems, setProgressItems] = useState<ProgressItem[]>([]);

//   const [model, setModel] = useState<string>(Constants.DEFAULT_MODEL);
//   const [subtask, setSubtask] = useState<string>(Constants.DEFAULT_SUBTASK);
//   const [quantized, setQuantized] = useState<boolean>(false);
//   const [multilingual, setMultilingual] = useState<boolean>(
//     Constants.DEFAULT_MULTILINGUAL
//   );
//   const [language, setLanguage] = useState<string>(Constants.DEFAULT_LANGUAGE);

//   const onInputChange = useCallback(() => {
//     setTranscript(undefined);
//   }, []);

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const postRequest = useCallback(
//     async (audioData: AudioBuffer | undefined) => {
//       if (audioData) {
//         setTranscript(undefined);
//         setIsBusy(true);

//         // biome-ignore lint/suspicious/noImplicitAnyLet: <explanation>
//         let audio;
//         if (audioData.numberOfChannels === 2) {
//           const SCALING_FACTOR = Math.sqrt(2);

//           const left = audioData.getChannelData(0);
//           const right = audioData.getChannelData(1);

//           audio = new Float32Array(left.length);
//           for (let i = 0; i < audioData.length; ++i) {
//             audio[i] = (SCALING_FACTOR * (left[i] + right[i])) / 2;
//           }
//         } else {
//           // If the audio is not stereo, we can just use the first channel:
//           audio = audioData.getChannelData(0);
//         }

//         // webWorker.postMessage({
//         //   audio,
//         //   model,
//         //   multilingual,
//         //   quantized,
//         //   subtask: multilingual ? subtask : null,
//         //   language: multilingual && language !== "auto" ? language : null,
//         // });
//       }
//     },
//     [model, multilingual, quantized, subtask, language]
//   );

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const transcriber = useMemo(() => {
//     return {
//       onInputChange,
//       isBusy,
//       isModelLoading,
//       progressItems,
//       start: postRequest,
//       output: transcript,
//       model,
//       setModel,
//       multilingual,
//       setMultilingual,
//       quantized,
//       setQuantized,
//       subtask,
//       setSubtask,
//       language,
//       setLanguage,
//     };
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [
//     isBusy,
//     isModelLoading,
//     progressItems,
//     postRequest,
//     transcript,
//     model,
//     multilingual,
//     quantized,
//     subtask,
//     language,
//   ]);

//   return transcriber;
// }

// const Constants = {
//   SAMPLING_RATE: 16000,
//   DEFAULT_MODEL: "Xenova/whisper-tiny",
//   DEFAULT_SUBTASK: "transcribe",
//   DEFAULT_LANGUAGE: "english",
//   DEFAULT_MULTILINGUAL: false,
// };

------END OF FILE----

/src/lib/utils.ts:
------BEGIN OF FILE----
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

------END OF FILE----

/src/jotai/modelStatusAtom.ts:
------BEGIN OF FILE----
// transcription model state

import { atom } from "jotai";

export type ModelStatus = "unknown" | "loading" | "ready" | "error";

export const modelStatusAtom = atom<ModelStatus>("unknown");
export const modelLoadingProgressAtom = atom<number>(0);
export type transcriptionModelName =
	| "onnx-community/whisper-base"
	| "onnx-community/whisper-large-turbo-v3";
export const transcriptionModelAtom = atom<transcriptionModelName>(
	"onnx-community/whisper-large-turbo-v3",
);

------END OF FILE----

/src/jotai/settingAtom.ts:
------BEGIN OF FILE----
import { atomWithStorage } from "jotai/utils";

export type TranscriptionModel = "onnx-community/whisper-base";

// List of supported languages:
// https://help.openai.com/en/articles/7031512-whisper-api-faq
// https://github.com/openai/whisper/blob/248b6cb124225dd263bb9bd32d060b6517e067f8/whisper/tokenizer.py#L79
export const LANGUAGES = {
	en: "english",
	zh: "chinese",
	de: "german",
	es: "spanish/castilian",
	ru: "russian",
	ko: "korean",
	fr: "french",
	ja: "japanese",
	pt: "portuguese",
	tr: "turkish",
	pl: "polish",
	ca: "catalan/valencian",
	nl: "dutch/flemish",
	ar: "arabic",
	sv: "swedish",
	it: "italian",
	id: "indonesian",
	hi: "hindi",
	fi: "finnish",
	vi: "vietnamese",
	he: "hebrew",
	uk: "ukrainian",
	el: "greek",
	ms: "malay",
	cs: "czech",
	ro: "romanian/moldavian/moldovan",
	da: "danish",
	hu: "hungarian",
	ta: "tamil",
	no: "norwegian",
	th: "thai",
	ur: "urdu",
	hr: "croatian",
	bg: "bulgarian",
	lt: "lithuanian",
	la: "latin",
	mi: "maori",
	ml: "malayalam",
	cy: "welsh",
	sk: "slovak",
	te: "telugu",
	fa: "persian",
	lv: "latvian",
	bn: "bengali",
	sr: "serbian",
	az: "azerbaijani",
	sl: "slovenian",
	kn: "kannada",
	et: "estonian",
	mk: "macedonian",
	br: "breton",
	eu: "basque",
	is: "icelandic",
	hy: "armenian",
	ne: "nepali",
	mn: "mongolian",
	bs: "bosnian",
	kk: "kazakh",
	sq: "albanian",
	sw: "swahili",
	gl: "galician",
	mr: "marathi",
	pa: "punjabi/panjabi",
	si: "sinhala/sinhalese",
	km: "khmer",
	sn: "shona",
	yo: "yoruba",
	so: "somali",
	af: "afrikaans",
	oc: "occitan",
	ka: "georgian",
	be: "belarusian",
	tg: "tajik",
	sd: "sindhi",
	gu: "gujarati",
	am: "amharic",
	yi: "yiddish",
	lo: "lao",
	uz: "uzbek",
	fo: "faroese",
	ht: "haitian creole/haitian",
	ps: "pashto/pushto",
	tk: "turkmen",
	nn: "nynorsk",
	mt: "maltese",
	sa: "sanskrit",
	lb: "luxembourgish/letzeburgesch",
	my: "myanmar/burmese",
	bo: "tibetan",
	tl: "tagalog",
	mg: "malagasy",
	as: "assamese",
	tt: "tatar",
	haw: "hawaiian",
	ln: "lingala",
	ha: "hausa",
	ba: "bashkir",
	jw: "javanese",
	su: "sundanese",
} as const;

// language set to union of values of LANGUAGES
export type TranscriptionLanguage = (typeof LANGUAGES)[keyof typeof LANGUAGES];

export type TranscriptionSettings = {
	language: TranscriptionLanguage;
};

export const transcriptionSettingsAtom = atomWithStorage<TranscriptionSettings>(
	"transcriptionSettings",
	{
		language: "english" as TranscriptionLanguage,
	},
);

------END OF FILE----

/src/whisper-worker.d.ts:
------BEGIN OF FILE----
/* eslint-disable @typescript-eslint/no-explicit-any */
export declare module "./whisper-worker.js" {
	export declare function processWhisperMessage(
		audio: Float32Array,
		language: string,
		// biome-ignore lint/suspicious/noExplicitAny: <explanation>
	): Promise<any>;
	export declare function initializeWhisperWorker(
		progressCallbackFunc: (progress: number) => void,
	): Promise<void>;
}

------END OF FILE----

/src/App.tsx:
------BEGIN OF FILE----
import Popup from "./Popup";
import { ThemeProvider } from "./components/theme-provider";
import { Toaster } from "./components/ui/toaster";

function App() {
	return (
		<ThemeProvider storageKey="chrome-extension-transcriptor-theme">
			<Popup />
			<Toaster />
		</ThemeProvider>
	);
}

export default App;

------END OF FILE----

/src/main.tsx:
------BEGIN OF FILE----
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./globals.css";

// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
// biome-ignore lint/style/noNonNullAssertion: <explanation>
ReactDOM.createRoot(document.getElementById("root")!).render(
	<React.StrictMode>
		<App />
	</React.StrictMode>,
);

------END OF FILE----

/src/side-panel.tsx:
------BEGIN OF FILE----
import React from "react";
import ReactDOM from "react-dom/client";
import "./globals.css";
import { ThemeProvider } from "./components/theme-provider";
import { Toaster } from "./components/ui/toaster";
import SidePanelApp from "./side-panel-app";

// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
// biome-ignore lint/style/noNonNullAssertion: <explanation>
ReactDOM.createRoot(document.getElementById("root")!).render(
	<React.StrictMode>
		<ThemeProvider storageKey="chrome-extension-transcriptor-theme">
			<SidePanelApp />
			<Toaster />
		</ThemeProvider>
	</React.StrictMode>,
);

------END OF FILE----

/src/summarizer.ts:
------BEGIN OF FILE----
import { Readability } from "@mozilla/readability";
import TurndownService from "turndown";

export async function summarizeWebPage(language: string): Promise<string> {
	// get current tab content
	console.debug("summarizeWebPage");
	const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
	if (!tab.id) {
		throw new Error("No active tab found");
	}
	const [{ result: content }] = await chrome.scripting.executeScript({
		target: { tabId: tab.id },
		func: () => document.documentElement.outerHTML,
	});
	if (!content) {
		throw new Error("Failed to get content from the active tab");
	}

	// Extract article content using Readability
	const doc = new DOMParser().parseFromString(content, "text/html");
	const reader = new Readability(doc);
	const article = reader.parse();

	if (!article) {
		throw new Error("Failed to extract article content");
	}

	// Convert article content to markdown using Turndown
	const turndownService = new TurndownService();
	const markdown = turndownService.turndown(article.content);

	const markdownLines = markdown.split("\n");

	// extract first N lines to avoid exceeding the input limit
	const maxLength = 40;
	if (markdownLines.length > maxLength) {
		markdownLines.splice(maxLength);
	}

	// Generate summary using Gemini Nano
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	const session = await window.ai.assistant.create({
		systemPrompt:
			"You are helpful assistant to summarize web article. Your output is markdown formatted. please summary with bullet points and meaningful sections.",
		topK: 10,
		temperature: 0,
	});

	const markdownPrompt = markdownLines.join("\n");

	const prompt = `Summarize the following text.:\n\n${markdownPrompt}`;
	console.debug("prompt", prompt);
	let summary = await session.prompt(prompt);
	session.destroy();

	// Translate the summary to Japanese
	console.debug("language", language);
	// initialize session for tlanslation
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	const sessionTranslator = await window.ai.assistant.create({
		systemPrompt: "You are helpful assistant to translate the summary",
		topK: 10,
		temperature: 0,
	});

	if (language === "japanese") {
		summary = await sessionTranslator.prompt(
			`日本語に翻訳してください:\n\n${summary}`,
		);
		console.debug("translated", summary);
	}
	sessionTranslator.destroy();

	console.debug("summary", summary);

	// Add title and URL to the summary
	const titleAndUrl = `# [${tab.title}](${tab.url})\n\n`;
	return titleAndUrl + summary;
}

------END OF FILE----

/src/side-panel-app.tsx:
------BEGIN OF FILE----
// src/side-panel-app.tsx
import { useEffect, useState } from "react";
import { AiSummarizer } from "./components/ai-summarizer";
import { Button } from "./components/ui/button";
import { Textarea } from "./components/ui/textarea";
import { PromptArea } from "./components/PromptArea";
import { useToast } from "./components/ui/use-toast";
import { summarizeWebPage } from "./summarizer";
import { LanguageSelector } from "./components/LanguageSelector";
import { transcriptionSettingsAtom } from "./jotai/settingAtom";
import { useAtom } from "jotai";
import { modelLoadingProgressAtom, modelStatusAtom } from "./jotai/modelStatusAtom";
import { generateResponse } from "../utils/generateResponse";

const SidePanelApp: React.FC = () => {
  const [summary, setSummary] = useState("");
  const [transcriptionSettings, setTranscriptionSettings] = useAtom(transcriptionSettingsAtom);
  const [isSummaryLoading, setIsSummaryLoading] = useState(false);
  const [aiCapabilities, setAiCapabilities] = useState<{ available: string }>({ available: "no" });
  const [transcription, setTranscription] = useState("");
  const [modelStatus, setModelStatus] = useAtom(modelStatusAtom);
  const [loadingProgress, setLoadingProgress] = useAtom(modelLoadingProgressAtom);

  const { toast } = useToast();

  useEffect(() => {
    fetchAiCapabilities().then((capabilities) => {
      setAiCapabilities(capabilities);
    });

    chrome.runtime.onMessage.addListener((message) => {
      if (message.type === "transcript") {
        setTranscription((prev) => `${prev}\n${message.data}`);
      } else if (message.type === "model-status") {
        setModelStatus(message.data.status);
        if (message.data.status === "loading") {
          setLoadingProgress(message.data.progress);
        }
      }
    });
  }, [setModelStatus, setLoadingProgress]);

  const handleSummarize = async () => {
    setIsSummaryLoading(true);
    try {
      const result = await summarizeWebPage(transcriptionSettings.language);
      setSummary(result);
      toast({
        description: "Summarized",
        color: "success",
      });
    } catch (error) {
      console.error(error);
      setSummary(`Failed to summarize: ${error}`);
      toast({
        description: "Failed to summarize",
        color: "error",
      });
    } finally {
      setIsSummaryLoading(false);
    }
  };

  const handleSendPrompt = async (prompt: string) => {
    try {
      const response = await generateResponse(prompt, transcription);
      toast({
        description: response,
        color: "success",
      });
    } catch (error) {
      console.error(error);
      toast({
        description: "Failed to generate response",
        color: "error",
      });
    }
  };

  return (
    <div className="container">
      <div className="box-border">
        <div className="flex flex-col m-1 p-1">
          <h1>Transcription</h1>
          <div className="text-center mt-1">
            <Textarea value={transcription} rows={20} readOnly />
          </div>
          <div className="text-center">
            <h1>Model Status: {modelStatus}</h1>
            {modelStatus === "loading" && <p>{loadingProgress}% loaded</p>}
          </div>
        </div>
        <div className="flex flex-col m-1 p-1">
          <LanguageSelector
            language={transcriptionSettings.language}
            setLanguage={(language) =>
              setTranscriptionSettings((prev) => ({
                ...prev,
                language,
              }))
            }
          />
        </div>
        <div className="flex flex-col m-1 p-1">
          <PromptArea onSendPrompt={handleSendPrompt} />
        </div>
        <div className="flex flex-col m-1 p-1">
          <Button
            onClick={() => {
              navigator.clipboard.writeText(transcription);
              toast({
                description: "Copied to clipboard",
                color: "success",
                duration: 1000,
              });
            }}
          >
            Copy to Clipboard
          </Button>
        </div>
        {aiCapabilities.available === "no" && (
          <div className="flex flex-col m-1 p-1">
            <div className="text-center">
              <h1>AI Summarization is not available</h1>
              <p>
                AI Summarization is not available. Please make sure your chrome
                supports Prompt API.
              </p>
            </div>
          </div>
        )}
        {aiCapabilities.available !== "no" && (
          <AiSummarizer
            setLanguage={(language) =>
              setTranscriptionSettings((prev) => ({
                ...prev,
                language,
              }))
            }
            language={transcriptionSettings.language}
            isSummaryLoading={isSummaryLoading}
            handleSummarize={handleSummarize}
            summary={summary}
          />
        )}
      </div>
    </div>
  );
};

export default SidePanelApp;
------END OF FILE----

/src/index.css:
------BEGIN OF FILE----

------END OF FILE----

/src/background.ts:
------BEGIN OF FILE----
import { createStore } from "jotai";
import {
	initializeWhisperWorker,
	processWhisperMessage,
} from "./whisper-worker.js";
import {
	modelLoadingProgressAtom,
	modelStatusAtom,
} from "./jotai/modelStatusAtom.js";

const store = createStore();

chrome.action.onClicked.addListener(async (tab) => {
	if (tab.id === undefined) {
		console.debug("Tab ID is undefined");
		return;
	}
	console.debug("Tab ID:", tab.id);

	const existingContexts = await chrome.runtime.getContexts({});

	const offscreenDocument = existingContexts.find(
		(c) => c.contextType === "OFFSCREEN_DOCUMENT",
	);

	// If an offscreen document is not already open, create one.
	if (!offscreenDocument) {
		// Create an offscreen document.
		console.debug("creating offscreenDocument");
		await chrome.offscreen.createDocument({
			url: "offscreen.html",
			reasons: [chrome.offscreen.Reason.USER_MEDIA],
			justification: "Recording from chrome.tabCapture API",
		});
	}

	// once the offscreen document is ready, send the stream ID to start recording
	chrome.runtime.onMessage.addListener(async (message) => {
		console.debug("Received message", message);
		if (message.type === "offscreen-ready") {
			console.debug("Received offscreen-ready message");
			// Send the stream ID to the offscreen document to start recording.
			chrome.tabCapture.getMediaStreamId(
				{
					targetTabId: tab.id,
				},
				(streamId) => {
					if (!streamId) {
						console.error("service-worker: Failed to get stream ID");
						return;
					}
					console.debug("Stream ID:", streamId);
					chrome.runtime.sendMessage({
						type: "start-recording",
						target: "offscreen",
						streamId,
					});
					console.debug("Sent start-recording message");
				},
			);
		}
		if (message.type === "initialize-transcription-model") {
			console.debug("Received initialize-transcription-model message");
			await initializeModelLoading();
		}
		if (message.type === "transcription-message") {
			console.debug("Received transcripton message", message);
			const modelStatus = store.get(modelStatusAtom);
			if (modelStatus !== "ready" && modelStatus !== "loading") {
				console.debug("Model is not ready", modelStatus);
				await initializeModelLoading();

				return;
			}
			if (modelStatus === "loading") {
				console.debug("Model is loading");
				return;
			}
			const { serializedAudio, language } = message.data;
			const audio = new Float32Array(JSON.parse(serializedAudio));
			console.debug("audio, language", audio, language);
			const transcripted = (await processWhisperMessage(
				audio,
				language,
			)) as string[];

			chrome.runtime.sendMessage({
				type: "transcript",
				data: {
					transcripted: transcripted.join("\n"),
				},
			});
		}
	});

	console.debug("tab info:", tab);
	console.debug("tab url", tab.url);
});

async function initializeModelLoading() {
	store.set(modelStatusAtom, "loading");
	store.set(modelLoadingProgressAtom, 0);
	chrome.runtime.sendMessage({
		type: "model-status",
		data: {
			status: "loading",
			progress: 0,
		},
	});
	await initializeWhisperWorker((progress) => {
		store.set(modelLoadingProgressAtom, progress);
		chrome.runtime.sendMessage({
			type: "model-status",
			data: {
				status: "loading",
				progress,
			},
		});
	});
	store.set(modelStatusAtom, "ready");
	chrome.runtime.sendMessage({
		type: "model-status",
		data: {
			status: "ready",
		},
	});
}

------END OF FILE----

/src/offscreen.tsx:
------BEGIN OF FILE----
import React from "react";
import { useEffect } from "react";
import ReactDOM from "react-dom/client";
import "./globals.css";
import { useAtom } from "jotai";
import { transcriptionSettingsAtom } from "./jotai/settingAtom";

// https://github.com/huggingface/transformers.js/blob/7a58d6e11968dd85dc87ce37b2ab37213165889a/examples/webgpu-whisper/src/App.jsx
// const IS_WEBGPU_AVAILABLE = !!navigator.gpu;

const WHISPER_SAMPLING_RATE = 16_000;
const MAX_AUDIO_LENGTH = 30; // seconds
const MAX_SAMPLES = WHISPER_SAMPLING_RATE * MAX_AUDIO_LENGTH;

export const Offscreen: React.FC = () => {
	const [transcriptionSettings] = useAtom(transcriptionSettingsAtom);
	const language = transcriptionSettings.language;
	const recorderRef = React.useRef<MediaRecorder | null>(null);
	const [recording, setRecording] = React.useState(false);
	const audioContextRef = React.useRef<AudioContext | null>(null);
	const [chunks, setChunks] = React.useState<Blob[]>([]);

	const setupMediaRecorder = (streamId: string) => {
		if (recorderRef.current) return; // Already set

		navigator.mediaDevices
			.getUserMedia({
				audio: {
					// @ts-expect-error - Chrome-specific properties
					mandatory: {
						chromeMediaSource: "tab",
						chromeMediaSourceId: streamId,
					},
				},
			})
			.then((stream) => {
				console.debug("Setting up media recorder", stream);

				recorderRef.current = new MediaRecorder(stream);
				audioContextRef.current = new AudioContext({
					sampleRate: 16000,
				});

				// Continue to play the captured audio to the user.
				const output = new AudioContext();
				const source = output.createMediaStreamSource(
					recorderRef.current.stream,
				);
				source.connect(output.destination);

				recorderRef.current.onstart = () => {
					setRecording(true);
					setChunks([]);
				};
				recorderRef.current.ondataavailable = (e) => {
					if (e.data.size > 0) {
						console.debug("Received chunk", e.data);
						setChunks((prev) => [...prev, e.data]);

						// requestData after 25 seconds
						setTimeout(() => {
							if (recorderRef.current) recorderRef.current.requestData();
						}, 10 * 1000);
					} else {
						// Empty chunk received, so we request new data after a short timeout
						console.debug("Empty chunk received");
						setTimeout(() => {
							if (recorderRef.current) recorderRef.current.requestData();
						}, 25);
					}
				};

				recorderRef.current.onstop = () => {
					setRecording(false);
				};
				recorderRef.current.start();
			})
			.catch((err) => console.error("The following error occurred: ", err));
	};

	// transcription
	useEffect(() => {
		if (!recorderRef.current) return;
		if (!recording) return;

		if (chunks.length > 0) {
			// Generate from data
			const blob = new Blob(chunks, { type: recorderRef.current.mimeType });

			const fileReader = new FileReader();

			fileReader.onloadend = async () => {
				const arrayBuffer = fileReader.result;
				if (audioContextRef.current === null) {
					console.debug("Audio context is null");
					return;
				}
				if (!arrayBuffer) {
					console.debug("Array buffer is null");
					return;
				}
				if (!(arrayBuffer instanceof ArrayBuffer)) {
					console.debug("Array buffer is not an ArrayBuffer");
					return;
				}
				const decoded =
					await audioContextRef.current.decodeAudioData(arrayBuffer);
				let audio = decoded.getChannelData(0);
				if (audio.length > MAX_SAMPLES) {
					// Get last MAX_SAMPLES
					audio = audio.slice(-MAX_SAMPLES);
				}
				console.debug("Decoded audio", audio);

				const serializedAudio = JSON.stringify(Array.from(audio));

				// worker.current.postMessage({
				//   type: "generate",
				//   data: { audio, language },
				// });
				chrome.runtime.sendMessage({
					type: "transcription-message",
					data: {
						type: "generate",
						serializedAudio: serializedAudio,
						// model: "Xenova/whisper-tiny",
						// multilingual: true,
						// quantized: false,
						// subtask: "transcribe",
						language: language,
					},
				});
			};
			fileReader.readAsArrayBuffer(blob);
		} else {
			recorderRef.current?.requestData();
		}
	}, [recording, chunks, language]);

	const setupTriggeredRef = React.useRef(false);
	const setupOffscreen = () => {
		if (setupTriggeredRef.current) return;
		setupTriggeredRef.current = true;
		console.debug("Setting up offscreen script");
		chrome.runtime.onMessage.addListener(async (message) => {
			if (message.target !== "offscreen") return;
			console.debug("Received message", message);

			if (message.type === "start-recording") {
				console.debug("Received start-recording message", message.streamId);
				setupMediaRecorder(message.streamId);
			}
		});

		// send offscreen ready message
		chrome.runtime.sendMessage({
			type: "offscreen-ready",
		});
	};

	useEffect(() => {
		setupOffscreen();
	});
	return (
		<div>
			<h1>Offscreen</h1>
			{/* mic permission button */}
		</div>
	);
};

// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
// biome-ignore lint/style/noNonNullAssertion: <explanation>
ReactDOM.createRoot(document.getElementById("root")!).render(
	<React.StrictMode>
		<Offscreen />
	</React.StrictMode>,
);

------END OF FILE----

/src/vite-env.d.ts:
------BEGIN OF FILE----
/// <reference types="vite/client" />

------END OF FILE----

/src/whisper-worker.js:
------BEGIN OF FILE----
/* eslint-disable no-undef */
/* eslint-disable @typescript-eslint/no-unused-vars */
import {
	AutoProcessor,
	AutoTokenizer,
	TextStreamer,
	WhisperForConditionalGeneration,
	full,
} from "@huggingface/transformers";

const MAX_NEW_TOKENS = 64;

/**
 * This class uses the Singleton pattern to ensure that only one instance of the model is loaded.
 */

// biome-ignore lint/complexity/noStaticOnlyClass: <explanation>
class AutomaticSpeechRecognitionPipeline {
	static model_id = null;
	static tokenizer = null;
	static processor = null;
	static model = null;

	static async getInstance(progress_callback = null) {
		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		this.model_id = "onnx-community/whisper-large-v3-turbo";
		// this.model_id = "onnx-community/whisper-base";

		AutomaticSpeechRecognitionPipeline;
		AutomaticSpeechRecognitionPipeline.tokenizer ??=
			// biome-ignore lint/complexity/noThisInStatic: <explanation>
			AutoTokenizer.from_pretrained(this.model_id, {
				progress_callback,
			});
		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		this.processor ??= AutoProcessor.from_pretrained(this.model_id, {
			progress_callback,
		});

		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		this.model ??= WhisperForConditionalGeneration.from_pretrained(
			// biome-ignore lint/complexity/noThisInStatic: <explanation>
			this.model_id,
			{
				dtype: {
					encoder_model: "fp16", // 'fp16' works too
					decoder_model_merged: "q4", // or 'fp32' ('fp16' is broken)
				},
				device: "webgpu",
				progress_callback,
			},
		);
		// biome-ignore lint/complexity/noThisInStatic: <explanation>
		return Promise.all([this.tokenizer, this.processor, this.model]);
	}
}

let processing = false;
export async function processWhisperMessage(audio, language) {
	if (processing) return;
	processing = true;
	if (!audio) {
		console.debug("No audio data provided.");
		processing = false;
		return;
	}
	console.debug("processWhisperMessage", audio, language);
	// const audioF32 = new Float32Array(audio);
	// console.debug("audio", audioF32);

	// Tell the main thread we are starting
	// self.postMessage({ status: "start" });

	// Retrieve the text-generation pipeline.
	const [tokenizer, processor, model] =
		await AutomaticSpeechRecognitionPipeline.getInstance((data) => {
			// We also add a progress callback to the pipeline so that we can
			// track model loading.
			if (
				data.status === "progress" &&
				Math.ceil(data.progress * 100) % 10 === 0
			) {
				console.debug(`Model loading: ${data.progress}%`);
				chrome.runtime.sendMessage({ type: "whisper-progress", data });
			}
			// self.postMessage(data);
		});

	let startTime;
	let numTokens = 0;
	const callback_function = (output) => {
		startTime ??= performance.now();

		let tps;
		if (numTokens++ > 0) {
			tps = (numTokens / (performance.now() - startTime)) * 1000;
		}
		console.debug("callback_func/output", output);
		// self.postMessage({
		//   status: "update",
		//   output,
		//   tps,
		//   numTokens,
		// });
	};

	const streamer = new TextStreamer(tokenizer, {
		skip_prompt: true,
		skip_special_tokens: true,
		callback_function,
	});

	const inputs = await processor(audio);

	const outputs = await model.generate({
		...inputs,
		max_new_tokens: MAX_NEW_TOKENS,
		language,
		streamer,
	});

	const outputText = tokenizer.batch_decode(outputs, {
		skip_special_tokens: true,
	});

	// Send the output back to the main thread
	console.debug("outputText", outputText);
	processing = false;
	return outputText;
}

export async function initializeWhisperWorker(progress_callback) {
	// Load the pipeline and save it for future use.
	const [tokenizer, processor, model] =
		await AutomaticSpeechRecognitionPipeline.getInstance((data) => {
			// We also add a progress callback to the pipeline so that we can
			// track model loading.
			console.debug("data", data);
			if (
				data.status === "progress" &&
				Math.ceil(data.progress * 100) % 10 === 0
			) {
				console.debug(`Model loading: ${data.progress}%`);
				progress_callback(data.progress);
			}
			// self.postMessage(data);
		});

	// Run model with dummy input to compile shaders
	await model.generate({
		input_features: full([1, 128, 3000], 0.0),
		max_new_tokens: 1,
	});
}

------END OF FILE----

/src/Popup.tsx:
------BEGIN OF FILE----
import type React from "react";
import { useEffect, useState } from "react";
import { AiSummarizer } from "./components/ai-summarizer";
import { Textarea } from "./components/ui/textarea";
import { useToast } from "./components/ui/use-toast";
import { summarizeWebPage } from "./summarizer";

const getDefaultLanguage = () => {
	const browserLocale = navigator.language;
	if (browserLocale.startsWith("ja")) {
		return "japanese";
	}
	return "english";
};

const fetchAiCapabilities = async () => {
	if (!window.ai) {
		return {
			available: "no",
		};
	}

	const { available } = await window.ai.languageModel.capabilities();

	return {
		available,
	};
};

const Popup: React.FC = () => {
	const [summary, setSummary] = useState("");
	const [language, setLanguage] = useState(getDefaultLanguage());
	const [isSummaryLoading, setIsSummaryLoading] = useState(false);
	const [aiCapabilities, setAiCapabilities] = useState<{ available: string }>({
		available: "no",
	});
	const [transcription, setTranscription] = useState("");

	useEffect(() => {
		fetchAiCapabilities().then((capabilities) => {
			setAiCapabilities(capabilities);
		});

		chrome.runtime.onMessage.addListener((message) => {
			if (message.type === "transcript") {
				setTranscription((prev) => `${prev}\n${message.data}`);
			}
		});
	}, []);

	const { toast } = useToast();

	const handleSummarize = async () => {
		setIsSummaryLoading(true);
		try {
			const result = await summarizeWebPage(language);
			setSummary(result);
			toast({
				description: "Summarized",
				color: "success",
			});
		} catch (error) {
			console.error(error);
			setSummary(`Failed to summarize: ${error}`);
			toast({
				description: "Failed to summarize",
				color: "error",
			});
		} finally {
			setIsSummaryLoading(false);
		}
	};

	return (
		<div className="container">
			<div className="box-border h-auto w-[400px]">
				{/* Transcription from web speech api */}
				<div className="flex flex-col m-1 p-1">
					<div className="text-center">
						<h1>Transcription</h1>
						<Textarea value={transcription} rows={10} readOnly />
					</div>
				</div>

				{aiCapabilities.available === "no" && (
					<div className="flex flex-col m-1 p-1">
						<div className="text-center">
							<h1>AI Summarization is not available</h1>
							<p>
								AI Summarization is not available. Please make sure your chrome
								supports Prompt API.
							</p>
						</div>
					</div>
				)}
				{aiCapabilities.available !== "no" && (
					<AiSummarizer
						setLanguage={setLanguage}
						language={language}
						isSummaryLoading={isSummaryLoading}
						handleSummarize={handleSummarize}
						summary={summary}
					/>
				)}
			</div>
		</div>
	);
};

export default Popup;

------END OF FILE----

/src/globals.css:
------BEGIN OF FILE----
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	:root {
		--background: 0 0% 100%;
		--foreground: 240 10% 3.9%;

		--card: 0 0% 100%;
		--card-foreground: 240 10% 3.9%;

		--popover: 0 0% 100%;
		--popover-foreground: 240 10% 3.9%;

		--primary: 240 5.9% 10%;
		--primary-foreground: 0 0% 98%;

		--secondary: 240 4.8% 95.9%;
		--secondary-foreground: 240 5.9% 10%;

		--muted: 240 4.8% 95.9%;
		--muted-foreground: 240 3.8% 46.1%;

		--accent: 240 4.8% 95.9%;
		--accent-foreground: 240 5.9% 10%;

		--destructive: 0 84.2% 60.2%;
		--destructive-foreground: 0 0% 98%;

		--border: 240 5.9% 90%;
		--input: 240 5.9% 90%;
		--ring: 240 10% 3.9%;

		--radius: 0.5rem;
	}

	.dark {
		--background: 240 10% 3.9%;
		--foreground: 0 0% 98%;

		--card: 240 10% 3.9%;
		--card-foreground: 0 0% 98%;

		--popover: 240 10% 3.9%;
		--popover-foreground: 0 0% 98%;

		--primary: 0 0% 98%;
		--primary-foreground: 240 5.9% 10%;

		--secondary: 240 3.7% 15.9%;
		--secondary-foreground: 0 0% 98%;

		--muted: 240 3.7% 15.9%;
		--muted-foreground: 240 5% 64.9%;

		--accent: 240 3.7% 15.9%;
		--accent-foreground: 0 0% 98%;

		--destructive: 0 62.8% 30.6%;
		--destructive-foreground: 0 0% 98%;

		--border: 240 3.7% 15.9%;
		--input: 240 3.7% 15.9%;
		--ring: 240 4.9% 83.9%;
	}
}

@layer base {
	* {
		@apply border-border;
	}
	body {
		@apply bg-background text-foreground;
	}
}

------END OF FILE----

/src/utils/generateResponse.ts:
------BEGIN OF FILE----
// src/utils/generateResponse.ts
import { AutoTokenizer, AutoModelForCausalLM } from "@huggingface/transformers";

export async function generateResponse(prompt: string, transcript: string): Promise<string> {
  const tokenizer = await AutoTokenizer.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");
  const model = await AutoModelForCausalLM.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");

  const inputText = `${prompt}\n${transcript}`;
  const inputs = tokenizer.encode(inputText, { return_tensors: "pt" });

  const output = await model.generate(inputs, { max_length: 500 });
  const response = tokenizer.decode(output[0], { skip_special_tokens: true });

  return response;
}
------END OF FILE----

/src/components/theme-provider.tsx:
------BEGIN OF FILE----
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
	children: React.ReactNode;
	defaultTheme?: Theme;
	storageKey?: string;
};

type ThemeProviderState = {
	theme: Theme;
	setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
	theme: "system",
	setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
	children,
	defaultTheme = "system",
	storageKey = "vite-ui-theme",
	...props
}: ThemeProviderProps) {
	const [theme, setTheme] = useState<Theme>(
		() => (localStorage.getItem(storageKey) as Theme) || defaultTheme,
	);

	useEffect(() => {
		const root = window.document.documentElement;

		root.classList.remove("light", "dark");

		if (theme === "system") {
			const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
				.matches
				? "dark"
				: "light";

			root.classList.add(systemTheme);
			return;
		}

		root.classList.add(theme);
	}, [theme]);

	const value = {
		theme,
		setTheme: (theme: Theme) => {
			localStorage.setItem(storageKey, theme);
			setTheme(theme);
		},
	};

	return (
		<ThemeProviderContext.Provider {...props} value={value}>
			{children}
		</ThemeProviderContext.Provider>
	);
}

export const useTheme = () => {
	const context = useContext(ThemeProviderContext);

	if (context === undefined)
		throw new Error("useTheme must be used within a ThemeProvider");

	return context;
};

------END OF FILE----

/src/components/LanguageSelector.tsx:
------BEGIN OF FILE----
import type React from "react";
import * as Select from "@radix-ui/react-select";
import { ChevronDownIcon, ChevronUpIcon } from "@radix-ui/react-icons";
import { LANGUAGES, type TranscriptionLanguage } from "@/jotai/settingAtom";

export const LanguageSelector: React.FC<{
	language: TranscriptionLanguage;
	setLanguage: (language: TranscriptionLanguage) => void;
}> = ({ language, setLanguage }) => {
	const handleLanguageChange = (value: string) => {
		setLanguage(value as TranscriptionLanguage);
	};

	const names = Object.values(LANGUAGES);

	return (
		<Select.Root onValueChange={handleLanguageChange} defaultValue={language}>
			<Select.Trigger className="inline-flex h-[35px] items-center justify-center gap-[5px] rounded px-[15px] text-[13px] leading-none outline-none hover:bg-mauve3 focus:shadow-[0_0_0_2px]">
				<Select.Value
					placeholder="Select a language…"
					defaultValue={language}
				/>
				<Select.Icon>
					<ChevronDownIcon />
				</Select.Icon>
			</Select.Trigger>
			<Select.Portal>
				<Select.Content className="overflow-hidden rounded-md bg-black shadow-[0px_10px_38px_-10px_rgba(22,_23,_24,_0.35),0px_10px_20px_-15px_rgba(22,_23,_24,_0.2)]">
					<Select.ScrollUpButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronUpIcon />
					</Select.ScrollUpButton>
					<Select.Viewport className="p-[5px]">
						<Select.Group>
							<Select.Label className="px-[25px] text-xs leading-[25px]">
								Languages
							</Select.Label>
							{names.map((name) => (
								<SelectItem key={name} value={name}>
									{name}
								</SelectItem>
							))}
						</Select.Group>
					</Select.Viewport>
					<Select.ScrollDownButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronDownIcon />
					</Select.ScrollDownButton>
				</Select.Content>
			</Select.Portal>
		</Select.Root>
	);
};

interface SelectItemProps {
	children: React.ReactNode;
	value: string;
}

const SelectItem: React.FC<SelectItemProps> = ({ children, ...props }) => {
	return (
		<Select.Item
			{...props}
			className="relative flex h-[25px] select-none items-center px-[25px] text-[13px] leading-none data-[highlighted]:bg-violet9 data-[highlighted]:text-violet1"
		>
			<Select.ItemText>{children}</Select.ItemText>
		</Select.Item>
	);
};

------END OF FILE----

/src/components/PromptArea.tsx:
------BEGIN OF FILE----
// src/components/PromptArea.tsx
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { SendIcon } from "lucide-react";

interface PromptAreaProps {
  onSendPrompt: (prompt: string) => void;
}

export const PromptArea: React.FC<PromptAreaProps> = ({ onSendPrompt }) => {
  const [prompt, setPrompt] = useState("");

  const handleSendPrompt = () => {
    if (prompt.trim() !== "") {
      onSendPrompt(prompt);
      setPrompt("");
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <Textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        rows={4}
        placeholder="Enter your prompt here..."
      />
      <Button onClick={handleSendPrompt}>
        <SendIcon className="mr-2 h-4 w-4" /> Send
      </Button>
    </div>
  );
};
------END OF FILE----

/src/components/ai-summarizer.tsx:
------BEGIN OF FILE----
import { Label } from "@radix-ui/react-label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "@radix-ui/react-select";
import { Loader2 } from "lucide-react";
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { toast } from "./ui/use-toast";
import type { TranscriptionLanguage } from "@/jotai/settingAtom";

interface AiSummarizerProps {
	setLanguage: (e: TranscriptionLanguage) => void;
	language: string;
	isSummaryLoading: boolean;
	handleSummarize: () => Promise<void>;
	summary: string;
}

export const AiSummarizer: React.FC<AiSummarizerProps> = ({
	setLanguage,
	language,
	isSummaryLoading,
	handleSummarize,
	summary,
}) => {
	return (
		<div className="flex flex-col m-1 p-1">
			<div className="flex flex-row my-1 justify">
				<div className="basis-1/2">
					<div>
						<Label htmlFor="language">Summarization Language</Label>
						<Select
							onValueChange={(e) => {
								setLanguage(e as TranscriptionLanguage);
							}}
							defaultValue={language}
						>
							<SelectTrigger className="w-[180px]">
								<SelectValue
									placeholder="Select Language"
									defaultValue={language}
								/>
							</SelectTrigger>
							<SelectContent defaultValue={language} id="language">
								<SelectItem value="english">English</SelectItem>
								<SelectItem value="japanese">Japanese</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</div>
				<div className="basis-1/2 flex flex-col justify-end items-end my-1">
					{isSummaryLoading ? (
						<Button disabled variant={"outline"}>
							<Loader2 className="mr-2 h-4 w-4 animate-spin" />
							Summarizing...
						</Button>
					) : (
						<Button onClick={handleSummarize}>
							Summarize This Transcription
						</Button>
					)}
				</div>
			</div>
			<div className="basis-1/1 grid w-full gap-2">
				<Textarea value={summary} rows={10} readOnly />
				<Button
					variant={"outline"}
					onClick={() => {
						navigator.clipboard.writeText(summary).then(() => {
							toast({
								description: "Copied to clipboard",
							});
						});
					}}
				>
					Copy to Clipboard
				</Button>
			</div>
		</div>
	);
};

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/hooks/useTranscriber.ts:
------BEGIN OF FILE----
/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-unused-vars */
// https://github.com/xenova/whisper-web/blob/main/src/hooks/useTranscriber.ts
// import { useCallback, useMemo, useState } from "react";

// interface ProgressItem {
//   file: string;
//   loaded: number;
//   progress: number;
//   total: number;
//   name: string;
//   status: string;
// }

// interface TranscriberUpdateData {
//   data: [
//     string,
//     { chunks: { text: string; timestamp: [number, number | null] }[] }
//   ];
//   text: string;
// }

// interface TranscriberCompleteData {
//   data: {
//     text: string;
//     chunks: { text: string; timestamp: [number, number | null] }[];
//   };
// }

// export interface TranscriberData {
//   isBusy: boolean;
//   text: string;
//   chunks: { text: string; timestamp: [number, number | null] }[];
// }

// export interface Transcriber {
//   onInputChange: () => void;
//   isBusy: boolean;
//   isModelLoading: boolean;
//   progressItems: ProgressItem[];
//   start: (audioData: AudioBuffer | undefined) => void;
//   output?: TranscriberData;
//   model: string;
//   setModel: (model: string) => void;
//   multilingual: boolean;
//   setMultilingual: (model: boolean) => void;
//   quantized: boolean;
//   setQuantized: (model: boolean) => void;
//   subtask: string;
//   setSubtask: (subtask: string) => void;
//   language?: string;
//   setLanguage: (language: string) => void;
// }

// export function useTranscriber(): Transcriber {
//   const [transcript, setTranscript] = useState<TranscriberData | undefined>(
//     undefined
//   );
//   const [isBusy, setIsBusy] = useState(false);
//   const [isModelLoading, setIsModelLoading] = useState(false);

//   const [progressItems, setProgressItems] = useState<ProgressItem[]>([]);

//   const [model, setModel] = useState<string>(Constants.DEFAULT_MODEL);
//   const [subtask, setSubtask] = useState<string>(Constants.DEFAULT_SUBTASK);
//   const [quantized, setQuantized] = useState<boolean>(false);
//   const [multilingual, setMultilingual] = useState<boolean>(
//     Constants.DEFAULT_MULTILINGUAL
//   );
//   const [language, setLanguage] = useState<string>(Constants.DEFAULT_LANGUAGE);

//   const onInputChange = useCallback(() => {
//     setTranscript(undefined);
//   }, []);

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const postRequest = useCallback(
//     async (audioData: AudioBuffer | undefined) => {
//       if (audioData) {
//         setTranscript(undefined);
//         setIsBusy(true);

//         // biome-ignore lint/suspicious/noImplicitAnyLet: <explanation>
//         let audio;
//         if (audioData.numberOfChannels === 2) {
//           const SCALING_FACTOR = Math.sqrt(2);

//           const left = audioData.getChannelData(0);
//           const right = audioData.getChannelData(1);

//           audio = new Float32Array(left.length);
//           for (let i = 0; i < audioData.length; ++i) {
//             audio[i] = (SCALING_FACTOR * (left[i] + right[i])) / 2;
//           }
//         } else {
//           // If the audio is not stereo, we can just use the first channel:
//           audio = audioData.getChannelData(0);
//         }

//         // webWorker.postMessage({
//         //   audio,
//         //   model,
//         //   multilingual,
//         //   quantized,
//         //   subtask: multilingual ? subtask : null,
//         //   language: multilingual && language !== "auto" ? language : null,
//         // });
//       }
//     },
//     [model, multilingual, quantized, subtask, language]
//   );

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const transcriber = useMemo(() => {
//     return {
//       onInputChange,
//       isBusy,
//       isModelLoading,
//       progressItems,
//       start: postRequest,
//       output: transcript,
//       model,
//       setModel,
//       multilingual,
//       setMultilingual,
//       quantized,
//       setQuantized,
//       subtask,
//       setSubtask,
//       language,
//       setLanguage,
//     };
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [
//     isBusy,
//     isModelLoading,
//     progressItems,
//     postRequest,
//     transcript,
//     model,
//     multilingual,
//     quantized,
//     subtask,
//     language,
//   ]);

//   return transcriber;
// }

// const Constants = {
//   SAMPLING_RATE: 16000,
//   DEFAULT_MODEL: "Xenova/whisper-tiny",
//   DEFAULT_SUBTASK: "transcribe",
//   DEFAULT_LANGUAGE: "english",
//   DEFAULT_MULTILINGUAL: false,
// };

------END OF FILE----

/src/lib/utils.ts:
------BEGIN OF FILE----
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

------END OF FILE----

/src/jotai/modelStatusAtom.ts:
------BEGIN OF FILE----
// transcription model state

import { atom } from "jotai";

export type ModelStatus = "unknown" | "loading" | "ready" | "error";

export const modelStatusAtom = atom<ModelStatus>("unknown");
export const modelLoadingProgressAtom = atom<number>(0);
export type transcriptionModelName =
	| "onnx-community/whisper-base"
	| "onnx-community/whisper-large-turbo-v3";
export const transcriptionModelAtom = atom<transcriptionModelName>(
	"onnx-community/whisper-large-turbo-v3",
);

------END OF FILE----

/src/jotai/settingAtom.ts:
------BEGIN OF FILE----
import { atomWithStorage } from "jotai/utils";

export type TranscriptionModel = "onnx-community/whisper-base";

// List of supported languages:
// https://help.openai.com/en/articles/7031512-whisper-api-faq
// https://github.com/openai/whisper/blob/248b6cb124225dd263bb9bd32d060b6517e067f8/whisper/tokenizer.py#L79
export const LANGUAGES = {
	en: "english",
	zh: "chinese",
	de: "german",
	es: "spanish/castilian",
	ru: "russian",
	ko: "korean",
	fr: "french",
	ja: "japanese",
	pt: "portuguese",
	tr: "turkish",
	pl: "polish",
	ca: "catalan/valencian",
	nl: "dutch/flemish",
	ar: "arabic",
	sv: "swedish",
	it: "italian",
	id: "indonesian",
	hi: "hindi",
	fi: "finnish",
	vi: "vietnamese",
	he: "hebrew",
	uk: "ukrainian",
	el: "greek",
	ms: "malay",
	cs: "czech",
	ro: "romanian/moldavian/moldovan",
	da: "danish",
	hu: "hungarian",
	ta: "tamil",
	no: "norwegian",
	th: "thai",
	ur: "urdu",
	hr: "croatian",
	bg: "bulgarian",
	lt: "lithuanian",
	la: "latin",
	mi: "maori",
	ml: "malayalam",
	cy: "welsh",
	sk: "slovak",
	te: "telugu",
	fa: "persian",
	lv: "latvian",
	bn: "bengali",
	sr: "serbian",
	az: "azerbaijani",
	sl: "slovenian",
	kn: "kannada",
	et: "estonian",
	mk: "macedonian",
	br: "breton",
	eu: "basque",
	is: "icelandic",
	hy: "armenian",
	ne: "nepali",
	mn: "mongolian",
	bs: "bosnian",
	kk: "kazakh",
	sq: "albanian",
	sw: "swahili",
	gl: "galician",
	mr: "marathi",
	pa: "punjabi/panjabi",
	si: "sinhala/sinhalese",
	km: "khmer",
	sn: "shona",
	yo: "yoruba",
	so: "somali",
	af: "afrikaans",
	oc: "occitan",
	ka: "georgian",
	be: "belarusian",
	tg: "tajik",
	sd: "sindhi",
	gu: "gujarati",
	am: "amharic",
	yi: "yiddish",
	lo: "lao",
	uz: "uzbek",
	fo: "faroese",
	ht: "haitian creole/haitian",
	ps: "pashto/pushto",
	tk: "turkmen",
	nn: "nynorsk",
	mt: "maltese",
	sa: "sanskrit",
	lb: "luxembourgish/letzeburgesch",
	my: "myanmar/burmese",
	bo: "tibetan",
	tl: "tagalog",
	mg: "malagasy",
	as: "assamese",
	tt: "tatar",
	haw: "hawaiian",
	ln: "lingala",
	ha: "hausa",
	ba: "bashkir",
	jw: "javanese",
	su: "sundanese",
} as const;

// language set to union of values of LANGUAGES
export type TranscriptionLanguage = (typeof LANGUAGES)[keyof typeof LANGUAGES];

export type TranscriptionSettings = {
	language: TranscriptionLanguage;
};

export const transcriptionSettingsAtom = atomWithStorage<TranscriptionSettings>(
	"transcriptionSettings",
	{
		language: "english" as TranscriptionLanguage,
	},
);

------END OF FILE----

/src/utils/generateResponse.ts:
------BEGIN OF FILE----
// src/utils/generateResponse.ts
import { AutoTokenizer, AutoModelForCausalLM } from "@huggingface/transformers";

export async function generateResponse(prompt: string, transcript: string): Promise<string> {
  const tokenizer = await AutoTokenizer.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");
  const model = await AutoModelForCausalLM.from_pretrained("Xenova/Qwen1.5-0.5B-Chat");

  const inputText = `${prompt}\n${transcript}`;
  const inputs = tokenizer.encode(inputText, { return_tensors: "pt" });

  const output = await model.generate(inputs, { max_length: 500 });
  const response = tokenizer.decode(output[0], { skip_special_tokens: true });

  return response;
}
------END OF FILE----

/src/components/theme-provider.tsx:
------BEGIN OF FILE----
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
	children: React.ReactNode;
	defaultTheme?: Theme;
	storageKey?: string;
};

type ThemeProviderState = {
	theme: Theme;
	setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
	theme: "system",
	setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
	children,
	defaultTheme = "system",
	storageKey = "vite-ui-theme",
	...props
}: ThemeProviderProps) {
	const [theme, setTheme] = useState<Theme>(
		() => (localStorage.getItem(storageKey) as Theme) || defaultTheme,
	);

	useEffect(() => {
		const root = window.document.documentElement;

		root.classList.remove("light", "dark");

		if (theme === "system") {
			const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
				.matches
				? "dark"
				: "light";

			root.classList.add(systemTheme);
			return;
		}

		root.classList.add(theme);
	}, [theme]);

	const value = {
		theme,
		setTheme: (theme: Theme) => {
			localStorage.setItem(storageKey, theme);
			setTheme(theme);
		},
	};

	return (
		<ThemeProviderContext.Provider {...props} value={value}>
			{children}
		</ThemeProviderContext.Provider>
	);
}

export const useTheme = () => {
	const context = useContext(ThemeProviderContext);

	if (context === undefined)
		throw new Error("useTheme must be used within a ThemeProvider");

	return context;
};

------END OF FILE----

/src/components/LanguageSelector.tsx:
------BEGIN OF FILE----
import type React from "react";
import * as Select from "@radix-ui/react-select";
import { ChevronDownIcon, ChevronUpIcon } from "@radix-ui/react-icons";
import { LANGUAGES, type TranscriptionLanguage } from "@/jotai/settingAtom";

export const LanguageSelector: React.FC<{
	language: TranscriptionLanguage;
	setLanguage: (language: TranscriptionLanguage) => void;
}> = ({ language, setLanguage }) => {
	const handleLanguageChange = (value: string) => {
		setLanguage(value as TranscriptionLanguage);
	};

	const names = Object.values(LANGUAGES);

	return (
		<Select.Root onValueChange={handleLanguageChange} defaultValue={language}>
			<Select.Trigger className="inline-flex h-[35px] items-center justify-center gap-[5px] rounded px-[15px] text-[13px] leading-none outline-none hover:bg-mauve3 focus:shadow-[0_0_0_2px]">
				<Select.Value
					placeholder="Select a language…"
					defaultValue={language}
				/>
				<Select.Icon>
					<ChevronDownIcon />
				</Select.Icon>
			</Select.Trigger>
			<Select.Portal>
				<Select.Content className="overflow-hidden rounded-md bg-black shadow-[0px_10px_38px_-10px_rgba(22,_23,_24,_0.35),0px_10px_20px_-15px_rgba(22,_23,_24,_0.2)]">
					<Select.ScrollUpButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronUpIcon />
					</Select.ScrollUpButton>
					<Select.Viewport className="p-[5px]">
						<Select.Group>
							<Select.Label className="px-[25px] text-xs leading-[25px]">
								Languages
							</Select.Label>
							{names.map((name) => (
								<SelectItem key={name} value={name}>
									{name}
								</SelectItem>
							))}
						</Select.Group>
					</Select.Viewport>
					<Select.ScrollDownButton className="flex h-[25px] cursor-default items-center justify-center">
						<ChevronDownIcon />
					</Select.ScrollDownButton>
				</Select.Content>
			</Select.Portal>
		</Select.Root>
	);
};

interface SelectItemProps {
	children: React.ReactNode;
	value: string;
}

const SelectItem: React.FC<SelectItemProps> = ({ children, ...props }) => {
	return (
		<Select.Item
			{...props}
			className="relative flex h-[25px] select-none items-center px-[25px] text-[13px] leading-none data-[highlighted]:bg-violet9 data-[highlighted]:text-violet1"
		>
			<Select.ItemText>{children}</Select.ItemText>
		</Select.Item>
	);
};

------END OF FILE----

/src/components/PromptArea.tsx:
------BEGIN OF FILE----
// src/components/PromptArea.tsx
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { SendIcon } from "lucide-react";

interface PromptAreaProps {
  onSendPrompt: (prompt: string) => void;
}

export const PromptArea: React.FC<PromptAreaProps> = ({ onSendPrompt }) => {
  const [prompt, setPrompt] = useState("");

  const handleSendPrompt = () => {
    if (prompt.trim() !== "") {
      onSendPrompt(prompt);
      setPrompt("");
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <Textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        rows={4}
        placeholder="Enter your prompt here..."
      />
      <Button onClick={handleSendPrompt}>
        <SendIcon className="mr-2 h-4 w-4" /> Send
      </Button>
    </div>
  );
};
------END OF FILE----

/src/components/ai-summarizer.tsx:
------BEGIN OF FILE----
import { Label } from "@radix-ui/react-label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "@radix-ui/react-select";
import { Loader2 } from "lucide-react";
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { toast } from "./ui/use-toast";
import type { TranscriptionLanguage } from "@/jotai/settingAtom";

interface AiSummarizerProps {
	setLanguage: (e: TranscriptionLanguage) => void;
	language: string;
	isSummaryLoading: boolean;
	handleSummarize: () => Promise<void>;
	summary: string;
}

export const AiSummarizer: React.FC<AiSummarizerProps> = ({
	setLanguage,
	language,
	isSummaryLoading,
	handleSummarize,
	summary,
}) => {
	return (
		<div className="flex flex-col m-1 p-1">
			<div className="flex flex-row my-1 justify">
				<div className="basis-1/2">
					<div>
						<Label htmlFor="language">Summarization Language</Label>
						<Select
							onValueChange={(e) => {
								setLanguage(e as TranscriptionLanguage);
							}}
							defaultValue={language}
						>
							<SelectTrigger className="w-[180px]">
								<SelectValue
									placeholder="Select Language"
									defaultValue={language}
								/>
							</SelectTrigger>
							<SelectContent defaultValue={language} id="language">
								<SelectItem value="english">English</SelectItem>
								<SelectItem value="japanese">Japanese</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</div>
				<div className="basis-1/2 flex flex-col justify-end items-end my-1">
					{isSummaryLoading ? (
						<Button disabled variant={"outline"}>
							<Loader2 className="mr-2 h-4 w-4 animate-spin" />
							Summarizing...
						</Button>
					) : (
						<Button onClick={handleSummarize}>
							Summarize This Transcription
						</Button>
					)}
				</div>
			</div>
			<div className="basis-1/1 grid w-full gap-2">
				<Textarea value={summary} rows={10} readOnly />
				<Button
					variant={"outline"}
					onClick={() => {
						navigator.clipboard.writeText(summary).then(() => {
							toast({
								description: "Copied to clipboard",
							});
						});
					}}
				>
					Copy to Clipboard
				</Button>
			</div>
		</div>
	);
};

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/components/ui/toaster.tsx:
------BEGIN OF FILE----
import {
	Toast,
	ToastClose,
	ToastDescription,
	ToastProvider,
	ToastTitle,
	ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
	const { toasts } = useToast();

	return (
		<ToastProvider>
			{toasts.map(({ id, title, description, action, ...props }) => (
				<Toast key={id} {...props}>
					<div className="grid gap-1">
						{title && <ToastTitle>{title}</ToastTitle>}
						{description && <ToastDescription>{description}</ToastDescription>}
					</div>
					{action}
					<ToastClose />
				</Toast>
			))}
			<ToastViewport />
		</ToastProvider>
	);
}

------END OF FILE----

/src/components/ui/label.tsx:
------BEGIN OF FILE----
import * as LabelPrimitive from "@radix-ui/react-label";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

------END OF FILE----

/src/components/ui/use-toast.ts:
------BEGIN OF FILE----
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
	id: string;
	title?: React.ReactNode;
	description?: React.ReactNode;
	action?: ToastActionElement;
};

const actionTypes = {
	ADD_TOAST: "ADD_TOAST",
	UPDATE_TOAST: "UPDATE_TOAST",
	DISMISS_TOAST: "DISMISS_TOAST",
	REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
	count = (count + 1) % Number.MAX_SAFE_INTEGER;
	return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
	| {
			type: ActionType["ADD_TOAST"];
			toast: ToasterToast;
	  }
	| {
			type: ActionType["UPDATE_TOAST"];
			toast: Partial<ToasterToast>;
	  }
	| {
			type: ActionType["DISMISS_TOAST"];
			toastId?: ToasterToast["id"];
	  }
	| {
			type: ActionType["REMOVE_TOAST"];
			toastId?: ToasterToast["id"];
	  };

interface State {
	toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
	if (toastTimeouts.has(toastId)) {
		return;
	}

	const timeout = setTimeout(() => {
		toastTimeouts.delete(toastId);
		dispatch({
			type: "REMOVE_TOAST",
			toastId: toastId,
		});
	}, TOAST_REMOVE_DELAY);

	toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
	switch (action.type) {
		case "ADD_TOAST":
			return {
				...state,
				toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
			};

		case "UPDATE_TOAST":
			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === action.toast.id ? { ...t, ...action.toast } : t,
				),
			};

		case "DISMISS_TOAST": {
			const { toastId } = action;

			// ! Side effects ! - This could be extracted into a dismissToast() action,
			// but I'll keep it here for simplicity
			if (toastId) {
				addToRemoveQueue(toastId);
			} else {
				// biome-ignore lint/complexity/noForEach: <explanation>
				state.toasts.forEach((toast) => {
					addToRemoveQueue(toast.id);
				});
			}

			return {
				...state,
				toasts: state.toasts.map((t) =>
					t.id === toastId || toastId === undefined
						? {
								...t,
								open: false,
							}
						: t,
				),
			};
		}
		case "REMOVE_TOAST":
			if (action.toastId === undefined) {
				return {
					...state,
					toasts: [],
				};
			}
			return {
				...state,
				toasts: state.toasts.filter((t) => t.id !== action.toastId),
			};
	}
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
	memoryState = reducer(memoryState, action);
	// biome-ignore lint/complexity/noForEach: <explanation>
	listeners.forEach((listener) => {
		listener(memoryState);
	});
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
	const id = genId();

	const update = (props: ToasterToast) =>
		dispatch({
			type: "UPDATE_TOAST",
			toast: { ...props, id },
		});
	const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

	dispatch({
		type: "ADD_TOAST",
		toast: {
			...props,
			id,
			open: true,
			onOpenChange: (open) => {
				if (!open) dismiss();
			},
		},
	});

	return {
		id: id,
		dismiss,
		update,
	};
}

function useToast() {
	const [state, setState] = React.useState<State>(memoryState);

	// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
	React.useEffect(() => {
		listeners.push(setState);
		return () => {
			const index = listeners.indexOf(setState);
			if (index > -1) {
				listeners.splice(index, 1);
			}
		};
	}, [state]);

	return {
		...state,
		toast,
		dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
	};
}

export { useToast, toast };

------END OF FILE----

/src/components/ui/button.tsx:
------BEGIN OF FILE----
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-destructive-foreground hover:bg-destructive/90",
				outline:
					"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-4 py-2",
				sm: "h-9 rounded-md px-3",
				lg: "h-11 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

export interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button, buttonVariants };

------END OF FILE----

/src/components/ui/toast.tsx:
------BEGIN OF FILE----
import * as ToastPrimitives from "@radix-ui/react-toast";
import { type VariantProps, cva } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Viewport>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Viewport
		ref={ref}
		className={cn(
			"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
			className,
		)}
		{...props}
	/>
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
	"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
	{
		variants: {
			variant: {
				default: "border bg-background text-foreground",
				destructive:
					"destructive group border-destructive bg-destructive text-destructive-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

const Toast = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
		VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
	return (
		<ToastPrimitives.Root
			ref={ref}
			className={cn(toastVariants({ variant }), className)}
			{...props}
		/>
	);
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Action>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Action
		ref={ref}
		className={cn(
			"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
			className,
		)}
		{...props}
	/>
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Close>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Close
		ref={ref}
		className={cn(
			"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
			className,
		)}
		toast-close=""
		{...props}
	>
		<X className="h-4 w-4" />
	</ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Title>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Title
		ref={ref}
		className={cn("text-sm font-semibold", className)}
		{...props}
	/>
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
	React.ElementRef<typeof ToastPrimitives.Description>,
	React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
	<ToastPrimitives.Description
		ref={ref}
		className={cn("text-sm opacity-90", className)}
		{...props}
	/>
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
	type ToastProps,
	type ToastActionElement,
	ToastProvider,
	ToastViewport,
	Toast,
	ToastTitle,
	ToastDescription,
	ToastClose,
	ToastAction,
};

------END OF FILE----

/src/components/ui/select.tsx:
------BEGIN OF FILE----
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollUpButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronUp className="h-4 w-4" />
	</SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.ScrollDownButton
		ref={ref}
		className={cn(
			"flex cursor-default items-center justify-center py-1",
			className,
		)}
		{...props}
	>
		<ChevronDown className="h-4 w-4" />
	</SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
	SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectScrollUpButton />
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
			<SelectScrollDownButton />
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>

		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
	SelectScrollUpButton,
	SelectScrollDownButton,
};

------END OF FILE----

/src/components/ui/textarea.tsx:
------BEGIN OF FILE----
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

------END OF FILE----

/src/hooks/useTranscriber.ts:
------BEGIN OF FILE----
/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-unused-vars */
// https://github.com/xenova/whisper-web/blob/main/src/hooks/useTranscriber.ts
// import { useCallback, useMemo, useState } from "react";

// interface ProgressItem {
//   file: string;
//   loaded: number;
//   progress: number;
//   total: number;
//   name: string;
//   status: string;
// }

// interface TranscriberUpdateData {
//   data: [
//     string,
//     { chunks: { text: string; timestamp: [number, number | null] }[] }
//   ];
//   text: string;
// }

// interface TranscriberCompleteData {
//   data: {
//     text: string;
//     chunks: { text: string; timestamp: [number, number | null] }[];
//   };
// }

// export interface TranscriberData {
//   isBusy: boolean;
//   text: string;
//   chunks: { text: string; timestamp: [number, number | null] }[];
// }

// export interface Transcriber {
//   onInputChange: () => void;
//   isBusy: boolean;
//   isModelLoading: boolean;
//   progressItems: ProgressItem[];
//   start: (audioData: AudioBuffer | undefined) => void;
//   output?: TranscriberData;
//   model: string;
//   setModel: (model: string) => void;
//   multilingual: boolean;
//   setMultilingual: (model: boolean) => void;
//   quantized: boolean;
//   setQuantized: (model: boolean) => void;
//   subtask: string;
//   setSubtask: (subtask: string) => void;
//   language?: string;
//   setLanguage: (language: string) => void;
// }

// export function useTranscriber(): Transcriber {
//   const [transcript, setTranscript] = useState<TranscriberData | undefined>(
//     undefined
//   );
//   const [isBusy, setIsBusy] = useState(false);
//   const [isModelLoading, setIsModelLoading] = useState(false);

//   const [progressItems, setProgressItems] = useState<ProgressItem[]>([]);

//   const [model, setModel] = useState<string>(Constants.DEFAULT_MODEL);
//   const [subtask, setSubtask] = useState<string>(Constants.DEFAULT_SUBTASK);
//   const [quantized, setQuantized] = useState<boolean>(false);
//   const [multilingual, setMultilingual] = useState<boolean>(
//     Constants.DEFAULT_MULTILINGUAL
//   );
//   const [language, setLanguage] = useState<string>(Constants.DEFAULT_LANGUAGE);

//   const onInputChange = useCallback(() => {
//     setTranscript(undefined);
//   }, []);

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const postRequest = useCallback(
//     async (audioData: AudioBuffer | undefined) => {
//       if (audioData) {
//         setTranscript(undefined);
//         setIsBusy(true);

//         // biome-ignore lint/suspicious/noImplicitAnyLet: <explanation>
//         let audio;
//         if (audioData.numberOfChannels === 2) {
//           const SCALING_FACTOR = Math.sqrt(2);

//           const left = audioData.getChannelData(0);
//           const right = audioData.getChannelData(1);

//           audio = new Float32Array(left.length);
//           for (let i = 0; i < audioData.length; ++i) {
//             audio[i] = (SCALING_FACTOR * (left[i] + right[i])) / 2;
//           }
//         } else {
//           // If the audio is not stereo, we can just use the first channel:
//           audio = audioData.getChannelData(0);
//         }

//         // webWorker.postMessage({
//         //   audio,
//         //   model,
//         //   multilingual,
//         //   quantized,
//         //   subtask: multilingual ? subtask : null,
//         //   language: multilingual && language !== "auto" ? language : null,
//         // });
//       }
//     },
//     [model, multilingual, quantized, subtask, language]
//   );

//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>
//   const transcriber = useMemo(() => {
//     return {
//       onInputChange,
//       isBusy,
//       isModelLoading,
//       progressItems,
//       start: postRequest,
//       output: transcript,
//       model,
//       setModel,
//       multilingual,
//       setMultilingual,
//       quantized,
//       setQuantized,
//       subtask,
//       setSubtask,
//       language,
//       setLanguage,
//     };
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [
//     isBusy,
//     isModelLoading,
//     progressItems,
//     postRequest,
//     transcript,
//     model,
//     multilingual,
//     quantized,
//     subtask,
//     language,
//   ]);

//   return transcriber;
// }

// const Constants = {
//   SAMPLING_RATE: 16000,
//   DEFAULT_MODEL: "Xenova/whisper-tiny",
//   DEFAULT_SUBTASK: "transcribe",
//   DEFAULT_LANGUAGE: "english",
//   DEFAULT_MULTILINGUAL: false,
// };

------END OF FILE----

/src/lib/utils.ts:
------BEGIN OF FILE----
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

------END OF FILE----

/src/jotai/modelStatusAtom.ts:
------BEGIN OF FILE----
// transcription model state

import { atom } from "jotai";

export type ModelStatus = "unknown" | "loading" | "ready" | "error";

export const modelStatusAtom = atom<ModelStatus>("unknown");
export const modelLoadingProgressAtom = atom<number>(0);
export type transcriptionModelName =
	| "onnx-community/whisper-base"
	| "onnx-community/whisper-large-turbo-v3";
export const transcriptionModelAtom = atom<transcriptionModelName>(
	"onnx-community/whisper-large-turbo-v3",
);

------END OF FILE----

/src/jotai/settingAtom.ts:
------BEGIN OF FILE----
import { atomWithStorage } from "jotai/utils";

export type TranscriptionModel = "onnx-community/whisper-base";

// List of supported languages:
// https://help.openai.com/en/articles/7031512-whisper-api-faq
// https://github.com/openai/whisper/blob/248b6cb124225dd263bb9bd32d060b6517e067f8/whisper/tokenizer.py#L79
export const LANGUAGES = {
	en: "english",
	zh: "chinese",
	de: "german",
	es: "spanish/castilian",
	ru: "russian",
	ko: "korean",
	fr: "french",
	ja: "japanese",
	pt: "portuguese",
	tr: "turkish",
	pl: "polish",
	ca: "catalan/valencian",
	nl: "dutch/flemish",
	ar: "arabic",
	sv: "swedish",
	it: "italian",
	id: "indonesian",
	hi: "hindi",
	fi: "finnish",
	vi: "vietnamese",
	he: "hebrew",
	uk: "ukrainian",
	el: "greek",
	ms: "malay",
	cs: "czech",
	ro: "romanian/moldavian/moldovan",
	da: "danish",
	hu: "hungarian",
	ta: "tamil",
	no: "norwegian",
	th: "thai",
	ur: "urdu",
	hr: "croatian",
	bg: "bulgarian",
	lt: "lithuanian",
	la: "latin",
	mi: "maori",
	ml: "malayalam",
	cy: "welsh",
	sk: "slovak",
	te: "telugu",
	fa: "persian",
	lv: "latvian",
	bn: "bengali",
	sr: "serbian",
	az: "azerbaijani",
	sl: "slovenian",
	kn: "kannada",
	et: "estonian",
	mk: "macedonian",
	br: "breton",
	eu: "basque",
	is: "icelandic",
	hy: "armenian",
	ne: "nepali",
	mn: "mongolian",
	bs: "bosnian",
	kk: "kazakh",
	sq: "albanian",
	sw: "swahili",
	gl: "galician",
	mr: "marathi",
	pa: "punjabi/panjabi",
	si: "sinhala/sinhalese",
	km: "khmer",
	sn: "shona",
	yo: "yoruba",
	so: "somali",
	af: "afrikaans",
	oc: "occitan",
	ka: "georgian",
	be: "belarusian",
	tg: "tajik",
	sd: "sindhi",
	gu: "gujarati",
	am: "amharic",
	yi: "yiddish",
	lo: "lao",
	uz: "uzbek",
	fo: "faroese",
	ht: "haitian creole/haitian",
	ps: "pashto/pushto",
	tk: "turkmen",
	nn: "nynorsk",
	mt: "maltese",
	sa: "sanskrit",
	lb: "luxembourgish/letzeburgesch",
	my: "myanmar/burmese",
	bo: "tibetan",
	tl: "tagalog",
	mg: "malagasy",
	as: "assamese",
	tt: "tatar",
	haw: "hawaiian",
	ln: "lingala",
	ha: "hausa",
	ba: "bashkir",
	jw: "javanese",
	su: "sundanese",
} as const;

// language set to union of values of LANGUAGES
export type TranscriptionLanguage = (typeof LANGUAGES)[keyof typeof LANGUAGES];

export type TranscriptionSettings = {
	language: TranscriptionLanguage;
};

export const transcriptionSettingsAtom = atomWithStorage<TranscriptionSettings>(
	"transcriptionSettings",
	{
		language: "english" as TranscriptionLanguage,
	},
);

------END OF FILE----





IMPORTANTE:

* Siempre proporciona respuestas completas y detalladas.
* Planifica tus pasos de manera estructurada antes de comenzar cualquier tarea.
* Asegúrate de que tus respuestas sean técnicamente precisas y de alta calidad.

A continuación, las tareas a completar:: 

